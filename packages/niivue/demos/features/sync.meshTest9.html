<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Niivue Lasso Edit - Segmentation Only</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #111;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }

    header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: #222;
      padding: 10px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #lassoCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    button {
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
    }

    button:hover {
      background: #666;
    }
  </style>
</head>

<body>
  <header>
    <button id="editBtn">í¸ì§‘ ëª¨ë“œ</button>
  </header>
  <canvas id="renderCanvas"></canvas>
  <canvas id="lassoCanvas"></canvas>

  <script type="module">
    import * as niivue from '../dist/index.js';

    // 1. Niivue ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    const nv = new niivue.Niivue({
      sliceType: niivue.SLICE_TYPE.RENDER,
      backColor: [0, 0, 0, 1],
      isOrientCube: true
    });
    await nv.attachTo('renderCanvas');

    // 2. ì»¤ìŠ¤í…€ ë ˆì´ë¸” ì»¬ëŸ¬ë§µ ì •ì˜ ë° ë“±ë¡
    const labelColorMap1 = {
      1: [255, 0, 0, 255],  // ë ˆì´ë¸” 1 â†’ ë¹¨ê°•, ì™„ì „ ë¶ˆíˆ¬ëª…
      2: [255, 255, 0, 255] // ë ˆì´ë¸” 2 â†’ ë…¸ë‘, ì™„ì „ ë¶ˆíˆ¬ëª…
    };
    const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap1);
    niivue.cmapper.addColormap('seg', segCmap);

    // 3. NRRD ë¡œë“œ ë° ë³¼ë¥¨ ì„¤ì •
    const nrrdBlob = await fetch('./data/inferred.nrrd').then(res => res.blob());
    const nrrdUrl = URL.createObjectURL(nrrdBlob);

    await nv.loadVolumes([{
      url: nrrdUrl,
      name: 'Seg.nrrd',
      colormap: 'seg',         // 'seg' ì»¬ëŸ¬ë§µ ì‚¬ìš©
      indexedColors: true,
      opacity: 1.0,
      alphaThreshold: 0.0,
      visible: true
    }]);

    // 4. LUT ì ìš©
    const segVolume = nv.volumes[0];
    const maxLabelValue = 2;
    const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);
    segVolume.lut = labelLUT.lut;
    segVolume.cal_min = labelLUT.min;
    segVolume.cal_max = labelLUT.max;

    nv.updateGLVolume();
    nv.drawScene();
    console.log('ì„¸ê·¸ë©˜í…Œì´ì…˜ ë³¼ë¥¨ ë¡œë“œ ì™„ë£Œ');

    // ===============================
    // ë¼ì˜ ê´€ë ¨ ì´ˆê¸°í™”
    // ===============================
    const lassoCanvas = document.getElementById('lassoCanvas');
    const ctx = lassoCanvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    function resizeCanvas() {
      lassoCanvas.width = window.innerWidth;
      lassoCanvas.height = window.innerHeight;
    }

    let isEditing = false;
    let drawing = false;
    let points = [];

    document.getElementById('editBtn').onclick = () => {
      isEditing = !isEditing;
      console.log(isEditing ? 'í¸ì§‘ ëª¨ë“œ ON' : 'í¸ì§‘ ëª¨ë“œ OFF');
      lassoCanvas.style.pointerEvents = isEditing ? 'auto' : 'none';
      nv.opts.dragMode = isEditing ? nv.dragModes.none : nv.dragModes.rotate;
    };

    lassoCanvas.addEventListener('mousedown', e => {
      if (!isEditing) return;
      drawing = true;
      points = [[e.offsetX, e.offsetY]];
    });

    lassoCanvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      points.push([e.offsetX, e.offsetY]);
      drawLasso();
    });

    lassoCanvas.addEventListener('mouseup', () => {
      if (!drawing) return;
      drawing = false;
      closeLasso();
      applyLassoToSegmentation();
      points = [];
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
    });

    function drawLasso() {
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
      ctx.beginPath();
      ctx.moveTo(points[0][0], points[0][1]);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function closeLasso() {
      if (points.length > 2) {
        ctx.lineTo(points[0][0], points[0][1]);
        ctx.stroke();
      }
    }

    // ===============================
    // ë¼ì˜ ì˜ì—­ â†’ ì„¸ê·¸ë©˜í…Œì´ì…˜ì— ë ˆì´ë¸” 2 ì ìš©
    // ===============================
    function applyLassoToSegmentation() {
      try {
        const segVolume = nv.volumes[0];
        const img = segVolume.img;
        for (let i = 0; i < img.length; i++) {
          img[i] = 2;  // ë ˆì´ë¸” 2(ë…¸ë‘)
        }
        nv.updateGLVolume();
        nv.drawScene();
        console.log(`ë¼ì˜ ì˜ì—­ ë…¸ë‘ìœ¼ë¡œ ë³€ê²½: ${img.length} voxels`);
      } catch (err) {
        console.error('ë¼ì˜ ì ìš© ì¤‘ ì˜¤ë¥˜:', err);
      }
    }

    function makeNiivueColormapFromLabelColorMap(labelColorMap) {
      const I = [], R = [], G = [], B = [], A = [];

      for (let i = 0; i <= 255; i++) {
        I.push(i);
        if (labelColorMap[i]) {
          const [r, g, b, a = 255] = labelColorMap[i];
          R.push(r);
          G.push(g);
          B.push(b);
          A.push(a);
        } else {
          R.push(0);
          G.push(0);
          B.push(0);
          A.push(0);
        }
      }

      console.log("ğŸ§© ì™„ì„±ëœ Colormap:", { I, R: R.slice(0, 16), G: G.slice(0, 16), B: B.slice(0, 16), A: A.slice(0, 16) });
      return { I, R, G, B, A };
    }
  </script>
</body>

</html>