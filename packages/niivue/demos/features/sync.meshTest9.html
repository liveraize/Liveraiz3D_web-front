<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Niivue Lasso Edit - Segmentation Only</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #111;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }

    header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: #222;
      padding: 10px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #lassoCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    button {
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
    }

    button:hover {
      background: #666;
    }
  </style>
</head>

<body>
  <header>
    <button id="editBtn">편집 모드</button>
  </header>
  <canvas id="renderCanvas"></canvas>
  <canvas id="lassoCanvas"></canvas>

  <script type="module">
    import * as niivue from '../dist/index.js';

    // 1. Niivue 인스턴스 생성
    const nv = new niivue.Niivue({
      sliceType: niivue.SLICE_TYPE.RENDER,
      backColor: [0, 0, 0, 1],
      isOrientCube: true
    });
    await nv.attachTo('renderCanvas');

    // 2. 커스텀 레이블 컬러맵 정의 및 등록
    const labelColorMap1 = {
      1: [255, 0, 0, 255],  // 레이블 1 → 빨강, 완전 불투명
      2: [255, 255, 0, 255] // 레이블 2 → 노랑, 완전 불투명
    };
    const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap1);
    niivue.cmapper.addColormap('seg', segCmap);

    // 3. NRRD 로드 및 볼륨 설정
    const nrrdBlob = await fetch('./data/inferred.nrrd').then(res => res.blob());
    const nrrdUrl = URL.createObjectURL(nrrdBlob);

    await nv.loadVolumes([{
      url: nrrdUrl,
      name: 'Seg.nrrd',
      colormap: 'seg',         // 'seg' 컬러맵 사용
      indexedColors: true,
      opacity: 1.0,
      alphaThreshold: 0.0,
      visible: true
    }]);

    // 4. LUT 적용
    const segVolume = nv.volumes[0];
    const maxLabelValue = 2;
    const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);
    segVolume.lut = labelLUT.lut;
    segVolume.cal_min = labelLUT.min;
    segVolume.cal_max = labelLUT.max;

    nv.updateGLVolume();
    nv.drawScene();
    console.log('세그멘테이션 볼륨 로드 완료');

    // ===============================
    // 라쏘 관련 초기화
    // ===============================
    const lassoCanvas = document.getElementById('lassoCanvas');
    const ctx = lassoCanvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    function resizeCanvas() {
      lassoCanvas.width = window.innerWidth;
      lassoCanvas.height = window.innerHeight;
    }

    let isEditing = false;
    let drawing = false;
    let points = [];

    document.getElementById('editBtn').onclick = () => {
      isEditing = !isEditing;
      console.log(isEditing ? '편집 모드 ON' : '편집 모드 OFF');
      lassoCanvas.style.pointerEvents = isEditing ? 'auto' : 'none';
      nv.opts.dragMode = isEditing ? nv.dragModes.none : nv.dragModes.rotate;
    };

    lassoCanvas.addEventListener('mousedown', e => {
      if (!isEditing) return;
      drawing = true;
      points = [[e.offsetX, e.offsetY]];
    });

    lassoCanvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      points.push([e.offsetX, e.offsetY]);
      drawLasso();
    });

    lassoCanvas.addEventListener('mouseup', () => {
      if (!drawing) return;
      drawing = false;
      closeLasso();
      applyLassoToSegmentation();
      points = [];
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
    });

    function drawLasso() {
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
      ctx.beginPath();
      ctx.moveTo(points[0][0], points[0][1]);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function closeLasso() {
      if (points.length > 2) {
        ctx.lineTo(points[0][0], points[0][1]);
        ctx.stroke();
      }
    }

    // ===============================
    // 라쏘 영역 → 세그멘테이션에 레이블 2 적용
    // ===============================
    function applyLassoToSegmentation() {
      try {
        const segVolume = nv.volumes[0];
        const img = segVolume.img;
        for (let i = 0; i < img.length; i++) {
          img[i] = 2;  // 레이블 2(노랑)
        }
        nv.updateGLVolume();
        nv.drawScene();
        console.log(`라쏘 영역 노랑으로 변경: ${img.length} voxels`);
      } catch (err) {
        console.error('라쏘 적용 중 오류:', err);
      }
    }

    function makeNiivueColormapFromLabelColorMap(labelColorMap) {
      const I = [], R = [], G = [], B = [], A = [];

      for (let i = 0; i <= 255; i++) {
        I.push(i);
        if (labelColorMap[i]) {
          const [r, g, b, a = 255] = labelColorMap[i];
          R.push(r);
          G.push(g);
          B.push(b);
          A.push(a);
        } else {
          R.push(0);
          G.push(0);
          B.push(0);
          A.push(0);
        }
      }

      console.log("🧩 완성된 Colormap:", { I, R: R.slice(0, 16), G: G.slice(0, 16), B: B.slice(0, 16), A: A.slice(0, 16) });
      return { I, R, G, B, A };
    }
  </script>
</body>

</html>