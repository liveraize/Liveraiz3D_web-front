<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header>
    <select id="sliceType">
      <option value="0">Axial</option>
      <option value="1">Coronal</option>
      <option value="2">Sagittal</option>
      <option value="4">Render</option>
      <option value="3" selected>A+C+S+R</option>
    </select>
    <input type="file" id="folderInput" webkitdirectory multiple />
    <span id="status"></span>
    <input type="file" id="nrrdInput" accept=".nrrd" />
    <button id="convertBtn">NRRD → OBJ 변환</button>
    <span id="status">NRRD 파일을 선택하세요.</span>
    <button id="editorBtn">✂️ 편집 모드</button>
    <button id="undoBtn">↩️ 되돌리기</button>
  </header>
  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
    </div>
    <div id="viewerArea">
      <div id="bottomHalf">
        <!-- <canvas id="canvasRender"></canvas> -->
        <canvas id="threeCanvas"></canvas>
        <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
        <div id="scissorIcon" style="
  position: absolute;
  z-index: 100;
  pointer-events: none;
  display: none;
  font-size: 20px;
">✂️</div>
      </div>
      <div id="topHalf">
        <canvas id="canvasMulti"></canvas>
      </div>
    </div>
  </div>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';

    const threeMeshes = [];
    let hiddenFaces = new Map();
    let undoStack = [];
    let lassoPoints = [];
    let lassoActive = false;
    let editMode = false;
    let lassoCanvas, ctx;

    window.addEventListener("DOMContentLoaded", initThreeJSRenderer);

    function toScreen(pos, camera, canvas) {
      const vector = pos.clone().project(camera);
      const rect = canvas.getBoundingClientRect();
      return {
        x: (vector.x + 1) / 2 * rect.width,
        y: (-vector.y + 1) / 2 * rect.height
      };
    }

    function isInsideLasso(point) {
      let inside = false;
      for (let i = 0, j = lassoPoints.length - 1; i < lassoPoints.length; j = i++) {
        const xi = lassoPoints[i].x, yi = lassoPoints[i].y;
        const xj = lassoPoints[j].x, yj = lassoPoints[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function drawLassoPath() {
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);

      if (lassoPoints.length < 2) return;

      ctx.beginPath();
      ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
      for (let i = 1; i < lassoPoints.length; i++) {
        ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
      }

      // 선은 열린 상태로 그린다 (닫지 않음!)
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
    }

    function hideFace(mesh, faceIndex) {
      const geometry = mesh.geometry;
      if (!geometry.index) return;
      const indexAttr = geometry.index;
      console.log(geometry.index instanceof THREE.BufferAttribute);
      indexAttr.setX(faceIndex * 3, 0);
      indexAttr.setX(faceIndex * 3 + 1, 0);
      indexAttr.setX(faceIndex * 3 + 2, 0);
      geometry.index.needsUpdate = true;
    }

    function undoLastHide() {
      const last = undoStack.pop();
      if (!last) return;
      const { mesh, faceIndex, indices } = last;
      const geometry = mesh.geometry;
      geometry.index.setXYZ(faceIndex, indices[0], indices[1], indices[2]);
      geometry.index.needsUpdate = true;
    }

    async function initThreeJSRenderer() {
      const canvas = document.getElementById("threeCanvas");
      const loadedObjects = [];
      let loadedCount = 0;

      lassoCanvas = document.createElement('canvas');
      lassoCanvas.id = 'lassoCanvas';
      lassoCanvas.style.position = 'absolute';
      lassoCanvas.style.left = canvas.offsetLeft + 'px';
      lassoCanvas.style.top = canvas.offsetTop + 'px';
      lassoCanvas.style.pointerEvents = 'none';
      lassoCanvas.style.zIndex = 10;
      lassoCanvas.width = canvas.clientWidth * window.devicePixelRatio;
      lassoCanvas.height = canvas.clientHeight * window.devicePixelRatio;
      lassoCanvas.style.width = canvas.clientWidth + 'px';
      lassoCanvas.style.height = canvas.clientHeight + 'px';
      document.body.appendChild(lassoCanvas);
      ctx = lassoCanvas.getContext('2d');
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.z = 400;
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x8888ff);
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1);
      scene.add(light);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      document.getElementById('editorBtn').addEventListener('click', () => {
        editMode = !editMode;
        canvas.style.cursor = editMode ? 'crosshair' : 'default';
        controls.enabled = !editMode;
        document.getElementById('editorBtn').textContent = editMode ? '✅ 편집 중 (클릭해서 종료)' : '✂️ 편집 모드';

        // ✂️ 가위 아이콘 표시/숨김
        scissorIcon.style.display = editMode ? 'block' : 'none';

        // 편집 모드 종료 시 선 및 점 초기화
        if (!editMode) {
          clearLassoPath();
          lassoPoints = [];
        }
      });

      function clearLassoPath() {
        ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
      }

      function isLassoClosed() {
        return true; // 닫히는지 안 닫히는지는 더 이상 검사하지 않음
      }

      canvas.addEventListener('mousedown', (event) => {
        if (!editMode) return; // 편집 모드일 때만 동작

        lassoPoints = [];
        lassoActive = true;

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        lassoPoints.push({ x, y });
      });

      const scissorIcon = document.getElementById('scissorIcon');

      canvas.addEventListener('mouseenter', () => {
        if (editMode) {
          scissorIcon.style.display = 'block';
        }
      });

      canvas.addEventListener('mouseleave', () => {
        scissorIcon.style.display = 'none';
      });

      canvas.addEventListener('mousemove', e => {
        if (!editMode || !lassoActive) return;
        const rect = canvas.getBoundingClientRect();
        lassoPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
        scissorIcon.style.left = event.pageX + 10 + 'px';
        scissorIcon.style.top = event.pageY + 10 + 'px';
        drawLassoPath();
      });

      canvas.addEventListener('mouseup', () => {
        if (!editMode || lassoPoints.length < 3 || !isLassoClosed()) {
          console.warn("⚠️ 편집 취소: 선이 닫히지 않음");
          clearLassoPath();
          lassoPoints = [];
          return;
        }
        console.log("✅ mouseup: 편집 실행 시작");
        lassoActive = false;
        threeMeshes.forEach(mesh => {
          const geometry = mesh.geometry;
          if (!geometry || !geometry.attributes?.position || !geometry.index) {
            console.warn("⚠️ geometry 문제", { geometry });
            return;
          }

          const indexArray = geometry.index.array;
          const position = geometry.attributes.position;
          let hideCount = 0;

          for (let i = 0; i < indexArray.length; i += 3) {
            const a = indexArray[i];
            const b = indexArray[i + 1];
            const c = indexArray[i + 2];

            const vA = new THREE.Vector3().fromBufferAttribute(position, a).applyMatrix4(mesh.matrixWorld);
            const vB = new THREE.Vector3().fromBufferAttribute(position, b).applyMatrix4(mesh.matrixWorld);
            const vC = new THREE.Vector3().fromBufferAttribute(position, c).applyMatrix4(mesh.matrixWorld);

            const screenA = toScreen(vA, camera, canvas);
            const screenB = toScreen(vB, camera, canvas);
            const screenC = toScreen(vC, camera, canvas);

            const inLasso = isInsideLasso(screenA) && isInsideLasso(screenB) && isInsideLasso(screenC);
            if (inLasso) {
              hideFace(mesh, i / 3);
              hideCount++;
            }
          }

          console.log(`🔍 ${mesh.userData.label}: 잘린 face 개수:`, hideCount);
        });
        clearLassoPath();     // ★ 선 제거 추가
        lassoPoints = [];     // ★ 좌표 초기화
      });

      document.getElementById("undoBtn").addEventListener('click', undoLastHide);

      const baseUrl = "http://127.0.0.1:5000/uploads/meshes/temp123";
      const objFiles = [
        "segment_HV.obj", "segment_LLS.obj", "segment_LMS.obj",
        "segment_PV.obj", "segment_RAS.obj", "segment_RPS.obj", "segment_Spigelian.obj"
      ];

      const mtlLoader = new MTLLoader();
      mtlLoader.setResourcePath(baseUrl + "/");
      mtlLoader.setPath(baseUrl + "/");
      mtlLoader.load("segments.mtl", materials => {
        materials.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(baseUrl + "/");
        objFiles.forEach(filename => {
          objLoader.load(filename, (object) => {
            object.traverse((child) => {
              if (child instanceof THREE.Mesh) {
                // 강제로 인덱스 생성
                if (!child.geometry.index) {
                  child.geometry = BufferGeometryUtils.mergeVertices(child.geometry);
                }

                if (!child.geometry.index) {
                  console.warn(`❌ ${child.userData.label} - 인덱스 생성 실패`);
                  return;
                }

                child.material.transparent = true;
                child.material.opacity = 1.0;
                child.material.depthWrite = true;
                child.material.side = THREE.FrontSide;

                child.userData.label = filename.replace('.obj', '').replace('segment_', '');
                threeMeshes.push(child);
              }
            });

            loadedObjects.push(object);
            scene.add(object);
            loadedCount++;

            if (loadedCount === objFiles.length) {
              // ✅ 중심 정렬 코드 추가
              const fullBox = new THREE.Box3();
              loadedObjects.forEach(obj => fullBox.expandByObject(obj));

              const center = new THREE.Vector3();
              fullBox.getCenter(center);

              loadedObjects.forEach(obj => obj.position.sub(center));

              camera.lookAt(0, 0, 0);
              controls.target.set(0, 0, 0);
              controls.update();

              animate();
              renderThreeMeshListUI(threeMeshes);
            }
          });
        });

      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        light.position.copy(camera.position);
        renderer.render(scene, camera);
      }
      animate();
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh) => {
        if (!mesh.material) return; // material 없는 경우 무시

        const labelText = mesh.userData.label || mesh.name;
        const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);
        const opacity = mesh.material.opacity ?? 1;

        const row = document.createElement('div');
        meshListDiv.appendChild(row);
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? '👁️' : '🙈';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          eye.innerHTML = mesh.visible ? '👁️' : '🙈';
        };

        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.margin = '0 10px';
        colorBox.style.background = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`;
        colorBox.style.border = '1px solid #aaa';

        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '16px';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        slider.value = opacity;
        slider.style.width = '80px';

        const sliderValue = document.createElement('span');
        sliderValue.innerText = opacity.toFixed(2);
        sliderValue.style.marginLeft = '6px';
        sliderValue.style.fontSize = '12px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          mesh.material.opacity = val;
          sliderValue.innerText = val.toFixed(2);
        };

        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);

        labelContainer.appendChild(label);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }
  </script>

  <!-- <script type="module">
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    const threeMeshes = [];

     window.addEventListener("DOMContentLoaded", initThreeJSRenderer);

    async function initThreeJSRenderer() {
      const canvas = document.getElementById("threeCanvas");

      // 카메라 설정
      const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.z = 400;

      // 렌더러
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      // 씬
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x8888ff);

      // 조명
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1);
      scene.add(light);

      // OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;

      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI; // 상하 자유 회전
      controls.minAzimuthAngle = -Infinity;
      controls.maxAzimuthAngle = Infinity;

      controls.screenSpacePanning = false; // 이 줄이 핵심


      // 모델 파일 경로
      const baseUrl = "http://127.0.0.1:5000/uploads/meshes/temp123";
      const objFiles = [
        "segment_HV.obj",
        "segment_LLS.obj",
        "segment_LMS.obj",
        "segment_PV.obj",
        "segment_RAS.obj",
        "segment_RPS.obj",
        "segment_Spigelian.obj"
      ];

      const mtlLoader = new MTLLoader();
      mtlLoader.setResourcePath(baseUrl + "/");
      mtlLoader.setPath(baseUrl + "/");

      mtlLoader.load("segments.mtl", (materials) => {
        materials.preload();

        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(baseUrl + "/");

        const loadedObjects = [];
        let loadedCount = 0;

        objFiles.forEach((filename) => {
          objLoader.load(filename, (object) => {
            // 반투명 설정
            object.traverse((child) => {
              if (child instanceof THREE.Mesh) {
                child.material.transparent = true;   // 투명 비활성화
                child.material.opacity = 1.0;         // 완전 불투명
                child.material.depthWrite = true;     // 깊이 버퍼 활성화 → 내부 안보임
                child.material.side = THREE.FrontSide; // 일반적으로는 FrontSide만
              }
              child.userData.label = filename.replace('.obj', '').replace('segment_', '');
              threeMeshes.push(child);
            });

            loadedObjects.push(object);
            scene.add(object);
            loadedCount++;

            // 모든 obj 로드 완료 후 중심 정렬
            if (loadedCount === objFiles.length) {
              const fullBox = new THREE.Box3();
              loadedObjects.forEach(obj => fullBox.expandByObject(obj));

              const center = new THREE.Vector3();
              fullBox.getCenter(center);

              loadedObjects.forEach(obj => obj.position.sub(center));

              camera.lookAt(0, 0, 0);
              controls.target.set(0, 0, 0);
              controls.update();

              animate();
              renderThreeMeshListUI(threeMeshes);
            }
          });
        });
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        light.position.copy(camera.position); // 카메라와 같이 움직이게
        renderer.render(scene, camera);
      }
    }
   

    function createMeshControlRow(mesh) {
      const label = mesh.userData.label || mesh.name || "Mesh";

      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.marginBottom = '8px';

      // 👁️ 아이콘
      const eye = document.createElement('span');
      eye.innerHTML = mesh.visible ? '👁️' : '🙈';
      eye.style.cursor = 'pointer';
      eye.style.fontSize = '20px';
      eye.onclick = () => {
        mesh.visible = !mesh.visible;
        eye.innerHTML = mesh.visible ? '👁️' : '🙈';
      };

      // 색상 박스
      const color = mesh.material?.color || new THREE.Color(0.5, 0.5, 0.5);
      const colorBox = document.createElement('span');
      colorBox.style.display = 'inline-block';
      colorBox.style.width = '24px';
      colorBox.style.height = '24px';
      colorBox.style.margin = '0 10px';
      colorBox.style.background = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
      colorBox.style.border = '1px solid #aaa';
      colorBox.style.borderRadius = '4px';

      // 레이블
      const name = document.createElement('span');
      name.innerText = label;
      name.style.minWidth = '80px';
      name.style.fontSize = '14px';

      // 슬라이더
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = 0;
      slider.max = 1;
      slider.step = 0.01;
      slider.value = mesh.material.opacity ?? 1;
      slider.style.margin = '0 6px';
      slider.style.flex = '1';

      // 값 표시
      const value = document.createElement('span');
      value.innerText = slider.value;
      value.style.width = '32px';
      value.style.textAlign = 'right';

      slider.oninput = (e) => {
        const val = parseFloat(e.target.value);
        mesh.material.opacity = val;
        value.innerText = val.toFixed(2);
      };

      // 조립
      row.appendChild(eye);
      row.appendChild(colorBox);
      row.appendChild(name);
      row.appendChild(slider);
      row.appendChild(value);

      return row;
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh) => {
        if (!mesh.material) return; // material 없는 경우 무시

        const labelText = mesh.userData.label || mesh.name;
        const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);
        const opacity = mesh.material.opacity ?? 1;

        const row = document.createElement('div');
        meshListDiv.appendChild(row);
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? '👁️' : '🙈';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          eye.innerHTML = mesh.visible ? '👁️' : '🙈';
        };

        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.margin = '0 10px';
        colorBox.style.background = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`;
        colorBox.style.border = '1px solid #aaa';

        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '16px';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        slider.value = opacity;
        slider.style.width = '80px';

        const sliderValue = document.createElement('span');
        sliderValue.innerText = opacity.toFixed(2);
        sliderValue.style.marginLeft = '6px';
        sliderValue.style.fontSize = '12px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          mesh.material.opacity = val;
          sliderValue.innerText = val.toFixed(2);
        };

        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);

        labelContainer.appendChild(label);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }
  </script> -->

  <script type="module">
    import * as niivue from '../dist/index.js'; // 또는 CDN 사용

    let nvRender; // 전역 선언

    let nvMulti = null;
    const preloadCache = {};


    async function initNiivueMultiViewer(niiUrl, nrrdUrl) {
      // 1. LUT 미리 생성 (세그먼트용)
      const { segCmap, labelLUT } = await loadColormapAndLUT(nrrdUrl);

      // 2. 볼륨 리스트 생성
      const volumeList = [
        { url: niiUrl, colormap: 'gray', opacity: 1 },
        { url: nrrdUrl, colormap: 'seg', cal_min: labelLUT.min, cal_max: labelLUT.max, opacity: 0.5 }
      ];

      // 3. 멀티플레인 뷰어 생성
      const nvMulti = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.MULTIPLANE,
        dragAndDropEnabled: false,
        isOrientCube: true,
        backColor: [0, 0, 0, 1],
        logLevel: "none"
      });

      await nvMulti.attachTo("canvasMulti");
      await nvMulti.loadVolumes(volumeList);

      // 4. flip/LUT 후 drawScene (반드시 volumeList가 로드된 후 적용)
      flipVolumeX(nvMulti.volumes[0]);
      flipVolumeX(nvMulti.volumes[1]);
      nvMulti.volumes[1].lut = labelLUT.lut;
      nvMulti.volumes[1].cal_min = labelLUT.min;
      nvMulti.volumes[1].cal_max = labelLUT.max;
      nvMulti.updateGLVolume();
      nvMulti.drawScene();
    }

    async function initNiivueViewers() {
      nvRender = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.RENDER,
        dragAndDropEnabled: false,
        isOrientCube: true,
        show3Dcrosshair: false,
        backColor: [0.5, 0.5, 1, 1],
        gradientOpacity: 0.3,
        logLevel: "none"
      });

      await nvRender.attachTo("canvasRender");
      nvRender.setSliceType(nvRender.sliceTypeRender);
    }

    const convertBtn = document.getElementById("convertBtn");
    const nrrdInput = document.getElementById("nrrdInput");
    let colorMap = {};
    convertBtn.addEventListener("click", async () => {
      if (!nrrdInput.files.length) {
        alert("NRRD 파일을 선택하세요");
        return;
      }

      const file = nrrdInput.files[0];
      const formData = new FormData();
      formData.append("file", file);
      formData.append("folder", "temp123"); // optional

      try {
        status.textContent = "OBJ 변환 중...";
        const res = await fetch("http://127.0.0.1:5000/nrrd-to-obj", {
          method: "POST",
          body: formData
        });

        if (!res.ok) throw new Error("서버 오류 발생");
        const json = await res.json();
        if (!json.success || !json.objUrls.length) throw new Error("변환 실패");


        const urlCT = '../images/CTLiver.nii.gz';
        const urlSeg = '../images/CTLiverSegmentation.nrrd';
        // 볼륨 리스트 준비
        await initNiivueMultiViewer(urlCT, urlSeg);

        // 1. 메쉬 리스트 준비
        const meshList = json.objUrls.map(url => ({
          url: "http://127.0.0.1:5000" + url,
          visible: true
        }));

        // 2. .mtl 파일 파싱해서 색상 매핑
        const mtlUrl = "http://127.0.0.1:5000" + json.mtlUrl;

        // // 3. 뷰어 초기화 및 메쉬 로드
        // colorMap = await parseMtlFile(mtlUrl);
        // await initNiivueViewers();
        // await nvRender.loadMeshes(meshList);

        // applyMeshColors(nvRender.meshes, colorMap, nvRender);

        // // 4. 메쉬 불러오기 후 UI 그리기
        // renderMeshListUI();



        // 1. MTL 파싱 및 뷰어/메쉬 로딩
        colorMap = await parseMtlFile(mtlUrl);
        await initNiivueViewers();
        await nvRender.loadMeshes(meshList);

        nvRender.meshes.forEach((mesh, idx) => {
          const matName = mesh.name.replace('.obj', '');
          const rgb = colorMap[matName] || [255, 0, 0];
          mesh.rgba255 = [rgb[0], rgb[1], rgb[2], 80]; // 0~255 (ex: 80=약 0.31)
          mesh.blend = true; // 무조건 true
          mesh.meshShaderIndex = 0; // Matte, 5(Hemispheric), 11(Toon) 등 추천
          mesh.updateMesh(nvRender.gl);
        });

        // 깊이 테스팅 설정 확인
        nvRender.gl.enable(nvRender.gl.DEPTH_TEST);
        nvRender.gl.depthFunc(nvRender.gl.LEQUAL);
        nvRender.drawScene();
        renderMeshListUI();

        window.nvRender = nvRender; // 전역에 저장

        status.textContent = "OBJ 시각화 및 색상 매핑 완료";
      } catch (err) {
        console.error(err);
        status.textContent = "오류 발생: " + err.message;
      }
    });

    function applyMeshColors(meshes, colorMap, nvRender) {
      const INITIAL_OPACITY = 0.1;

      meshes.forEach(mesh => {
        mesh.blend = true; // 항상 켜줌 (반투명 효과)
        mesh.opacity = INITIAL_OPACITY; // (사용자 관리용)
        // 색상 정의
        const matName = mesh.name.replace('.obj', '');
        let rgba;
        if (colorMap[matName]) {
          rgba = colorMap[matName].slice();
          rgba[3] = Math.round(255 * INITIAL_OPACITY);
        } else {
          rgba = [255, 0, 0, Math.round(255 * INITIAL_OPACITY)];
        }
        mesh.rgba255 = rgba;
        mesh.color = rgba.slice(0, 3).map(x => x / 255);

        mesh.updateMesh(nvRender.gl); // WebGL 갱신!
        // meshShader 옵션은 필요시 한 번만 (뷰 전체에 동일하게)
      });
      nvRender.drawScene();
      window.nvRender = nvRender;
    }

    // function applyMeshColors(meshes, colorMap, nvRender) {
    //   meshes.forEach(mesh => {
    //     console.log("🚀 ~ applyMeshColors ~ mesh:", mesh)

    //     // 필요에 따라 prefix 처리 등 조정
    //     const matName = mesh.name.replace('.obj', '');

    //     if (colorMap[matName]) {
    //       const rgba = colorMap[matName];
    //       mesh.rgba255 = rgba.slice();
    //       mesh.color = rgba.slice(0, 3).map(x => x / 255);
    //       mesh.updateMesh(nvRender.gl);
    //     } else {
    //       // 진단용: 매칭 안되면 빨간색
    //       mesh.rgba255 = [255, 0, 0, 255];
    //       mesh.color = [1, 0, 0];
    //       mesh.updateMesh(nvRender.gl);
    //     }
    //   });
    //   nvRender.drawScene();
    // }

    // 3. 메쉬 리스트 UI 렌더링
    function renderMeshListUI() {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = ''; // 초기화

      nvRender.meshes.forEach((mesh, idx) => {
        const matName = mesh.name.replace('.obj', '');
        const rgba = colorMap[matName] || [128, 128, 128, 255];
        const labelText = matName.replace(/^segment_/, '');

        // 컨테이너
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        // 눈 아이콘
        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? '👁️' : '🙈';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          // Niivue는 mesh.visible = false면 해당 mesh가 아예 안 나옴
          nvRender.updateGLVolume();
          nvRender.drawScene();
          renderMeshListUI(); // 상태(눈 아이콘) 갱신
        };

        // 색상 박스
        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.marginLeft = '10px';
        colorBox.style.marginRight = '10px';
        colorBox.style.background = `rgba(${rgba[0]},${rgba[1]},${rgba[2]},1)`;
        colorBox.style.borderRadius = '3px';
        colorBox.style.border = '1px solid #aaa';

        // 라벨 + opacity 슬라이더 컨테이너
        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        // 라벨
        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '20px';

        // Opacity 슬라이더
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        // mesh.opacity 값이 undefined면 1로 초기화
        if (typeof mesh.opacity !== 'number') mesh.opacity = 1;
        slider.value = mesh.opacity;

        slider.style.width = '60px';
        slider.title = '투명도';

        // 현재 opacity 값
        const sliderValue = document.createElement('span');
        sliderValue.innerText = mesh.opacity.toFixed(2);
        sliderValue.style.fontSize = '12px';
        sliderValue.style.marginLeft = '8px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          console.log("🚀 ~ nvRender.meshes.forEach ~ val:", val)
          mesh.opacity = val;
          if (mesh.rgba255) mesh.rgba255[3] = Math.round(255 * val);
          mesh.updateMesh(nvRender.gl);
          nvRender.drawScene();
          sliderValue.innerText = val.toFixed(2);
          console.log(`[slider] ${mesh.name} ${val}`, mesh.rgba255);
        };

        // 조립
        labelContainer.appendChild(label);
        // 라벨 아래에 슬라이더 + 값 표시
        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }

    // mtlText에서 newmtl ~ Kd 색상을 추출해서 colorMap 만들기
    function parseMtlColors(mtlText) {
      const colorMap = {};
      let currentMat = null;
      mtlText.split('\n').forEach(line => {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMat = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMat) {
          const [r, g, b] = line.split(' ').slice(1).map(x => Math.round(parseFloat(x) * 255));
          colorMap[currentMat] = [r, g, b, 255];
        }
      });

      return colorMap;
    }

    // .mtl 파일 파싱 함수
    async function parseMtlFile(mtlUrl) {
      const res = await fetch(mtlUrl);
      if (!res.ok) throw new Error("MTL 파일 로드 실패");
      const text = await res.text();
      const lines = text.split('\n');
      const colorMap = {};
      let currentMaterial = null;
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMaterial = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMaterial) {
          const [r, g, b] = line.split(' ').slice(1).map(Number);
          colorMap[currentMaterial] = [r * 255, g * 255, b * 255, 255];
          console.log(`[MTL파싱] ${currentMaterial} →`, colorMap[currentMaterial]);
        }
      }
      return colorMap;
    }

    // const toggleBtn = document.getElementById('toggleOrientation')
    // toggleBtn.addEventListener('click', () => {
    //   orientationVisible = !orientationVisible
    //   nv1.setIsOrientationTextVisible(orientationVisible)
    //   toggleBtn.textContent = orientationVisible ? 'Hide Orientation Text' : 'Show Orientation Text'
    // })


    // import * as niivue from '../dist/index.js';


    const status = document.getElementById('status');
    const folderInput = document.getElementById('folderInput');

    // const urlCT = '../images/CTLiver.nii.gz';
    // const urlCT = await preloadVolume('../images/CTLiver.nii.gz');
    // const urlSeg = '../images/CTLiverSegmentation.nrrd';
    // console.log("Preloaded:", { urlCT, urlSeg });
    // await loadAndVisualize(urlCT, urlSeg);

    folderInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files).filter(f => f.name.endsWith('.dcm'));
      if (!files.length) {
        status.textContent = "DICOM(.dcm) 파일이 없습니다.";
        return;
      }

      const fullPath = files[0].webkitRelativePath || '';
      const folderName = fullPath.split('/')[0] || 'default';
      status.textContent = `'${folderName}' 업로드 중...`;

      const formData = new FormData();
      files.forEach(f => formData.append('dicomFiles', f));
      formData.append('folder', folderName);

      try {
        const res = await fetch('http://127.0.0.1:5000/upload-and-infer', {
          method: 'POST',
          body: formData
        });
        const json = await res.json();
        if (!json.success) throw new Error(json.message);

        status.textContent = "시각화 준비 중...";
        // await loadAndVisualize(json.niiUrl, json.nrrdUrl);

        // const urlCT = '../images/CTLiver.nii.gz';
        // const urlSeg = '../images/CTLiverSegmentation.nrrd';
        // await loadAndVisualize(urlCT, urlSeg);

        status.textContent = "완료되었습니다.";
      } catch (err) {
        console.error(err);
        status.textContent = "❌ 오류: " + err.message;
      }
    });


    async function preloadVolume(url) {
      if (preloadCache[url]) return preloadCache[url];
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Fetch failed: ${url}`);
      const blob = await response.blob();
      const objectURL = URL.createObjectURL(blob);
      preloadCache[url] = objectURL;
      return objectURL;
    }

    async function loadAndVisualize(urlCT, urlSeg) {
      const { segCmap, labelLUT } = await loadColormapAndLUT(urlSeg);

      const volumeList = [
        { url: urlCT, colormap: 'gray', opacity: 1 },
        {
          url: urlSeg,
          colormap: 'seg',
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 1
        }
      ];

      // ✅ [2단계] 하나의 뷰어만 loadVolumes 실행
      const nvAxial = await setupViewer('canvasAxial', niivue.SLICE_TYPE.AXIAL);
      const nvCoronal = await setupViewer('canvasCoronal', niivue.SLICE_TYPE.CORONAL);
      const nvSagittal = await setupViewer('canvasSagittal', niivue.SLICE_TYPE.SAGITTAL);
      const nvRender = await setupViewer('canvasRender', niivue.SLICE_TYPE.RENDER);

      console.time("loadVolumes");
      await nvAxial.loadVolumes(volumeList);
      console.timeEnd("loadVolumes");
      // ✅ [3단계] 나머지 뷰어는 loadVolumes 없이 volumeList를 직접 설정
      await nvCoronal.loadVolumes(volumeList);
      await nvSagittal.loadVolumes(volumeList);
      await nvRender.loadVolumes([volumeList[1]]);

      // ✅ [4단계] LUT 및 flip 적용 (각각의 volume 객체에 대해)
      for (const nv of [nvAxial, nvCoronal, nvSagittal]) {
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        nv.updateGLVolume();
        // nv.drawScene();
      }

      nvRender.volumes[0].lut = labelLUT.lut;
      nvRender.volumes[0].cal_min = labelLUT.min;
      nvRender.volumes[0].cal_max = labelLUT.max;
      nvRender.updateGLVolume();
      nvRender.drawScene();

      // ✅ [5단계] 위치 동기화
      for (let nv of [nvAxial, nvCoronal, nvSagittal]) {
        nv.broadcastTo([nvAxial, nvCoronal, nvSagittal, nvRender]);
      }
      // nvAxial.broadcastTo([nvCoronal, nvSagittal, nvRender]); // 하나만 마스터로

      // ✅ [6단계] 컨트롤러 바인딩
      bindRenderControls(nvRender);
    }

    async function loadColormapAndLUT(urlSeg) {
      const segCmap = await makeNiivueColormap(urlSeg);
      niivue.cmapper.addColormap('seg', segCmap);
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, Math.max(...segCmap.I));
      return { segCmap, labelLUT };
    }

    async function makeNiivueColormap(nrrdUrl) {
      const raw = await parseNrrdColorMap(nrrdUrl);
      const I = [], R = [], G = [], B = [], A = [];
      for (let i = 0; i <= 255; i++) {
        if (raw[i]) {
          const { r, g, b, a } = raw[i];
          R.push(r); G.push(g); B.push(b); A.push(a); I.push(i);
        } else {
          R.push(0); G.push(0); B.push(0); A.push(0); I.push(i);
        }
      }
      return { I, R, G, B, A };
    }

    async function parseNrrdColorMap(urlSeg) {
      let text = await fetch(urlSeg).then(r => r.text());
      text = text
        .replace(/^segment(\d+)_color:=/gim, 'Segment$1_Color:=')
        .replace(/^segment(\d+)_labelvalue:=/gim, 'Segment$1_LabelValue:=')
        .split('\n').filter(line =>
          !/^segment\d+_(name|nameautogenerated|extent|id|layer|tags|colorautogenerated):=/i.test(line) &&
          !/^segmentation_/i.test(line)
        ).join('\n');

      const rawColor = {}, rawLabel = {};
      const reColor = /^Segment(\d+)_Color:=\s*([\d\s.]+)$/i;
      const reLabel = /^Segment(\d+)_LabelValue:=\s*(\d+)$/i;

      for (const line of text.split('\n')) {
        let m;
        if ((m = reColor.exec(line))) rawColor[m[1]] = m[2].trim().split(/\s+/).map(x => Math.round(+x * 255));
        if ((m = reLabel.exec(line))) rawLabel[m[1]] = +m[2];
      }

      const cmap = {};
      for (const idx in rawColor) {
        const lbl = rawLabel[idx];
        if (lbl !== undefined) {
          const [r, g, b] = rawColor[idx];
          cmap[lbl] = { r, g, b, a: 255 };
        }
      }
      if (!cmap[0]) cmap[0] = { r: 0, g: 0, b: 0, a: 0 };
      return cmap;
    }

    async function initViewers(viewConfigs) {
      const viewers = {};
      for (const { id, type } of viewConfigs) {
        viewers[id] = await setupViewer(id, type);
      }
      return viewers;
    }

    async function setupViewer(canvasId, sliceType) {
      const defaults = {
        backColor: [0, 0, 0, 1],
        show3Dcrosshair: true,
        logLevel: 'none',
        dragAndDropEnabled: false
      };
      if (sliceType === niivue.SLICE_TYPE.RENDER) {
        defaults.gradientOpacity = 0.3;
        defaults.backColor = [0.5, 0.5, 1, 1];
      }
      const nv = new niivue.Niivue(defaults);
      await nv.attachTo(canvasId);
      nv.setSliceType(sliceType);
      nv.opts.isOrientCube = true;
      return nv;
    }

    async function loadVolumesToSliceViews(viewers, volumeList, labelLUT) {
      for (let nv of viewers) {
        await nv.loadVolumes(volumeList);
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        // nv.updateGLVolume();
        nv.drawScene();
      }
    }

    function flipVolumeX(volume) {
      const dims = volume.dimsRAS;
      const xSize = dims[1], ySize = dims[2], zSize = dims[3];
      const flipped = new volume.img.constructor(volume.img.length);

      const sliceSize = xSize * ySize;
      for (let z = 0; z < zSize; z++) {
        const offsetZ = z * sliceSize;
        for (let y = 0; y < ySize; y++) {
          const rowOffset = offsetZ + y * xSize;
          for (let x = 0; x < xSize; x++) {
            const src = rowOffset + x;
            const dst = rowOffset + (xSize - 1 - x);
            flipped[dst] = volume.img[src];
          }
        }
      }
      volume.img = flipped;
    }

    async function loadVolumesToRenderView(nv, urlSeg, labelLUT) {
      await nv.loadVolumes([{
        url: urlSeg,
        colormap: 'seg',
        cal_min: labelLUT.min,
        cal_max: labelLUT.max,
        opacity: 1
      }]);
    }

    function bindRenderControls(nvRender) {
      // gradientOpacity.oninput = function () {
      //   nvRender.setGradientOpacity(this.value * 0.1);
      // };
      // illumination.oninput = function () {
      //   nvRender.setVolumeRenderIllumination(this.value * 0.1);
      // };
      // gradientOrder.onchange = function () {
      //   nvRender.opts.gradientOrder = parseInt(this.value);
      //   nvRender.updateGLVolume();
      // };
    }
  </script>

  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
    }

    header {
      width: 100vw;
      height: 56px;
      /* 필요에 따라 40~80px */
      min-height: 40px;
      background: #fff;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #mainLayout {
      display: flex;
      width: 100vw;
      height: calc(100vh - 56px);
      /* header 높이만큼 뺌 */
      overflow: hidden;
    }

    #meshSidebar {
      width: 220px;
      background: #fff;
      border-right: 1px solid #ddd;
      padding: 10px 0 10px 10px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
    }

    #viewerArea {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-width: 1184px;
    }

    #topHalf,
    #bottomHalf {
      width: 100%;
      height: 50%;
    }

    #threeCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }
  </style>
</body>

</html>