<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header>
    <select id="sliceType">
      <option value="0">Axial</option>
      <option value="1">Coronal</option>
      <option value="2">Sagittal</option>
      <option value="4">Render</option>
      <option value="3" selected>A+C+S+R</option>
    </select>
    <input type="file" id="folderInput" webkitdirectory multiple />
    <span id="status"></span>
    <input type="file" id="nrrdInput" accept=".nrrd" />
    <button id="convertBtn">NRRD ‚Üí OBJ Î≥ÄÌôò</button>
    <span id="status">NRRD ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</span>
    <button id="editorBtn">‚úÇÔ∏è Ìé∏Ïßë Î™®Îìú</button>
    <button id="undoBtn">‚Ü©Ô∏è ÎêòÎèåÎ¶¨Í∏∞</button>
  </header>
  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
    </div>
    <div id="viewerArea">
      <div id="bottomHalf">
        <!-- <canvas id="canvasRender"></canvas> -->
        <canvas id="threeCanvas"></canvas>
        <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
        <div id="scissorIcon" style="
  position: absolute;
  z-index: 100;
  pointer-events: none;
  display: none;
  font-size: 20px;
">‚úÇÔ∏è</div>
      </div>
      <div id="topHalf">
        <canvas id="canvasMulti"></canvas>
      </div>
    </div>
  </div>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';

    const threeMeshes = [];
    let hiddenFaces = new Map();
    let undoStack = [];
    let lassoPoints = [];
    let lassoActive = false;
    let editMode = false;
    let lassoCanvas, ctx;

    window.addEventListener("DOMContentLoaded", initThreeJSRenderer);

    function toScreen(pos, camera, canvas) {
      const vector = pos.clone().project(camera);
      const rect = canvas.getBoundingClientRect();
      return {
        x: (vector.x + 1) / 2 * rect.width,
        y: (-vector.y + 1) / 2 * rect.height
      };
    }

    function isInsideLasso(point) {
      let inside = false;
      for (let i = 0, j = lassoPoints.length - 1; i < lassoPoints.length; j = i++) {
        const xi = lassoPoints[i].x, yi = lassoPoints[i].y;
        const xj = lassoPoints[j].x, yj = lassoPoints[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function drawLassoPath() {
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);

      if (lassoPoints.length < 2) return;

      ctx.beginPath();
      ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
      for (let i = 1; i < lassoPoints.length; i++) {
        ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
      }

      // ÏÑ†ÏùÄ Ïó¥Î¶∞ ÏÉÅÌÉúÎ°ú Í∑∏Î¶∞Îã§ (Îã´ÏßÄ ÏïäÏùå!)
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
    }

    function hideFace(mesh, faceIndex) {
      const geometry = mesh.geometry;
      if (!geometry.index) return;
      const indexAttr = geometry.index;
      console.log(geometry.index instanceof THREE.BufferAttribute);
      indexAttr.setX(faceIndex * 3, 0);
      indexAttr.setX(faceIndex * 3 + 1, 0);
      indexAttr.setX(faceIndex * 3 + 2, 0);
      geometry.index.needsUpdate = true;
    }

    function undoLastHide() {
      const last = undoStack.pop();
      if (!last) return;
      const { mesh, faceIndex, indices } = last;
      const geometry = mesh.geometry;
      geometry.index.setXYZ(faceIndex, indices[0], indices[1], indices[2]);
      geometry.index.needsUpdate = true;
    }

    async function initThreeJSRenderer() {
      const canvas = document.getElementById("threeCanvas");
      const loadedObjects = [];
      let loadedCount = 0;

      lassoCanvas = document.createElement('canvas');
      lassoCanvas.id = 'lassoCanvas';
      lassoCanvas.style.position = 'absolute';
      lassoCanvas.style.left = canvas.offsetLeft + 'px';
      lassoCanvas.style.top = canvas.offsetTop + 'px';
      lassoCanvas.style.pointerEvents = 'none';
      lassoCanvas.style.zIndex = 10;
      lassoCanvas.width = canvas.clientWidth * window.devicePixelRatio;
      lassoCanvas.height = canvas.clientHeight * window.devicePixelRatio;
      lassoCanvas.style.width = canvas.clientWidth + 'px';
      lassoCanvas.style.height = canvas.clientHeight + 'px';
      document.body.appendChild(lassoCanvas);
      ctx = lassoCanvas.getContext('2d');
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.z = 400;
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x8888ff);
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1);
      scene.add(light);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      document.getElementById('editorBtn').addEventListener('click', () => {
        editMode = !editMode;
        canvas.style.cursor = editMode ? 'crosshair' : 'default';
        controls.enabled = !editMode;
        document.getElementById('editorBtn').textContent = editMode ? '‚úÖ Ìé∏Ïßë Ï§ë (ÌÅ¥Î¶≠Ìï¥ÏÑú Ï¢ÖÎ£å)' : '‚úÇÔ∏è Ìé∏Ïßë Î™®Îìú';

        // ‚úÇÔ∏è Í∞ÄÏúÑ ÏïÑÏù¥ÏΩò ÌëúÏãú/Ïà®ÍπÄ
        scissorIcon.style.display = editMode ? 'block' : 'none';

        // Ìé∏Ïßë Î™®Îìú Ï¢ÖÎ£å Ïãú ÏÑ† Î∞è Ï†ê Ï¥àÍ∏∞Ìôî
        if (!editMode) {
          clearLassoPath();
          lassoPoints = [];
        }
      });

      function clearLassoPath() {
        ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
      }

      function isLassoClosed() {
        return true; // Îã´ÌûàÎäîÏßÄ Ïïà Îã´ÌûàÎäîÏßÄÎäî Îçî Ïù¥ÏÉÅ Í≤ÄÏÇ¨ÌïòÏßÄ ÏïäÏùå
      }

      canvas.addEventListener('mousedown', (event) => {
        if (!editMode) return; // Ìé∏Ïßë Î™®ÎìúÏùº ÎïåÎßå ÎèôÏûë

        lassoPoints = [];
        lassoActive = true;

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        lassoPoints.push({ x, y });
      });

      const scissorIcon = document.getElementById('scissorIcon');

      canvas.addEventListener('mouseenter', () => {
        if (editMode) {
          scissorIcon.style.display = 'block';
        }
      });

      canvas.addEventListener('mouseleave', () => {
        scissorIcon.style.display = 'none';
      });

      canvas.addEventListener('mousemove', e => {
        if (!editMode || !lassoActive) return;
        const rect = canvas.getBoundingClientRect();
        lassoPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
        scissorIcon.style.left = event.pageX + 10 + 'px';
        scissorIcon.style.top = event.pageY + 10 + 'px';
        drawLassoPath();
      });

      canvas.addEventListener('mouseup', () => {
        if (!editMode || lassoPoints.length < 3 || !isLassoClosed()) {
          console.warn("‚ö†Ô∏è Ìé∏Ïßë Ï∑®ÏÜå: ÏÑ†Ïù¥ Îã´ÌûàÏßÄ ÏïäÏùå");
          clearLassoPath();
          lassoPoints = [];
          return;
        }
        console.log("‚úÖ mouseup: Ìé∏Ïßë Ïã§Ìñâ ÏãúÏûë");
        lassoActive = false;
        threeMeshes.forEach(mesh => {
          const geometry = mesh.geometry;
          if (!geometry || !geometry.attributes?.position || !geometry.index) {
            console.warn("‚ö†Ô∏è geometry Î¨∏Ï†ú", { geometry });
            return;
          }

          const indexArray = geometry.index.array;
          const position = geometry.attributes.position;
          let hideCount = 0;

          for (let i = 0; i < indexArray.length; i += 3) {
            const a = indexArray[i];
            const b = indexArray[i + 1];
            const c = indexArray[i + 2];

            const vA = new THREE.Vector3().fromBufferAttribute(position, a).applyMatrix4(mesh.matrixWorld);
            const vB = new THREE.Vector3().fromBufferAttribute(position, b).applyMatrix4(mesh.matrixWorld);
            const vC = new THREE.Vector3().fromBufferAttribute(position, c).applyMatrix4(mesh.matrixWorld);

            const screenA = toScreen(vA, camera, canvas);
            const screenB = toScreen(vB, camera, canvas);
            const screenC = toScreen(vC, camera, canvas);

            const inLasso = isInsideLasso(screenA) && isInsideLasso(screenB) && isInsideLasso(screenC);
            if (inLasso) {
              hideFace(mesh, i / 3);
              hideCount++;
            }
          }

          console.log(`üîç ${mesh.userData.label}: ÏûòÎ¶∞ face Í∞úÏàò:`, hideCount);
        });
        clearLassoPath();     // ‚òÖ ÏÑ† Ï†úÍ±∞ Ï∂îÍ∞Ä
        lassoPoints = [];     // ‚òÖ Ï¢åÌëú Ï¥àÍ∏∞Ìôî
      });

      document.getElementById("undoBtn").addEventListener('click', undoLastHide);

      const baseUrl = "http://127.0.0.1:5000/uploads/meshes/temp123";
      const objFiles = [
        "segment_HV.obj", "segment_LLS.obj", "segment_LMS.obj",
        "segment_PV.obj", "segment_RAS.obj", "segment_RPS.obj", "segment_Spigelian.obj"
      ];

      const mtlLoader = new MTLLoader();
      mtlLoader.setResourcePath(baseUrl + "/");
      mtlLoader.setPath(baseUrl + "/");
      mtlLoader.load("segments.mtl", materials => {
        materials.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(baseUrl + "/");
        objFiles.forEach(filename => {
          objLoader.load(filename, (object) => {
            object.traverse((child) => {
              if (child instanceof THREE.Mesh) {
                // Í∞ïÏ†úÎ°ú Ïù∏Îç±Ïä§ ÏÉùÏÑ±
                if (!child.geometry.index) {
                  child.geometry = BufferGeometryUtils.mergeVertices(child.geometry);
                }

                if (!child.geometry.index) {
                  console.warn(`‚ùå ${child.userData.label} - Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ïã§Ìå®`);
                  return;
                }

                child.material.transparent = true;
                child.material.opacity = 1.0;
                child.material.depthWrite = true;
                child.material.side = THREE.FrontSide;

                child.userData.label = filename.replace('.obj', '').replace('segment_', '');
                threeMeshes.push(child);
              }
            });

            loadedObjects.push(object);
            scene.add(object);
            loadedCount++;

            if (loadedCount === objFiles.length) {
              // ‚úÖ Ï§ëÏã¨ Ï†ïÎ†¨ ÏΩîÎìú Ï∂îÍ∞Ä
              const fullBox = new THREE.Box3();
              loadedObjects.forEach(obj => fullBox.expandByObject(obj));

              const center = new THREE.Vector3();
              fullBox.getCenter(center);

              loadedObjects.forEach(obj => obj.position.sub(center));

              camera.lookAt(0, 0, 0);
              controls.target.set(0, 0, 0);
              controls.update();

              animate();
              renderThreeMeshListUI(threeMeshes);
            }
          });
        });

      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        light.position.copy(camera.position);
        renderer.render(scene, camera);
      }
      animate();
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh) => {
        if (!mesh.material) return; // material ÏóÜÎäî Í≤ΩÏö∞ Î¨¥Ïãú

        const labelText = mesh.userData.label || mesh.name;
        const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);
        const opacity = mesh.material.opacity ?? 1;

        const row = document.createElement('div');
        meshListDiv.appendChild(row);
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
        };

        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.margin = '0 10px';
        colorBox.style.background = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`;
        colorBox.style.border = '1px solid #aaa';

        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '16px';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        slider.value = opacity;
        slider.style.width = '80px';

        const sliderValue = document.createElement('span');
        sliderValue.innerText = opacity.toFixed(2);
        sliderValue.style.marginLeft = '6px';
        sliderValue.style.fontSize = '12px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          mesh.material.opacity = val;
          sliderValue.innerText = val.toFixed(2);
        };

        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);

        labelContainer.appendChild(label);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }
  </script>

  <!-- <script type="module">
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    const threeMeshes = [];

     window.addEventListener("DOMContentLoaded", initThreeJSRenderer);

    async function initThreeJSRenderer() {
      const canvas = document.getElementById("threeCanvas");

      // Ïπ¥Î©îÎùº ÏÑ§Ï†ï
      const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.z = 400;

      // Î†åÎçîÎü¨
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      // Ïî¨
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x8888ff);

      // Ï°∞Î™Ö
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1);
      scene.add(light);

      // OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;

      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI; // ÏÉÅÌïò ÏûêÏú† ÌöåÏ†Ñ
      controls.minAzimuthAngle = -Infinity;
      controls.maxAzimuthAngle = Infinity;

      controls.screenSpacePanning = false; // Ïù¥ Ï§ÑÏù¥ ÌïµÏã¨


      // Î™®Îç∏ ÌååÏùº Í≤ΩÎ°ú
      const baseUrl = "http://127.0.0.1:5000/uploads/meshes/temp123";
      const objFiles = [
        "segment_HV.obj",
        "segment_LLS.obj",
        "segment_LMS.obj",
        "segment_PV.obj",
        "segment_RAS.obj",
        "segment_RPS.obj",
        "segment_Spigelian.obj"
      ];

      const mtlLoader = new MTLLoader();
      mtlLoader.setResourcePath(baseUrl + "/");
      mtlLoader.setPath(baseUrl + "/");

      mtlLoader.load("segments.mtl", (materials) => {
        materials.preload();

        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(baseUrl + "/");

        const loadedObjects = [];
        let loadedCount = 0;

        objFiles.forEach((filename) => {
          objLoader.load(filename, (object) => {
            // Î∞òÌà¨Î™Ö ÏÑ§Ï†ï
            object.traverse((child) => {
              if (child instanceof THREE.Mesh) {
                child.material.transparent = true;   // Ìà¨Î™Ö ÎπÑÌôúÏÑ±Ìôî
                child.material.opacity = 1.0;         // ÏôÑÏ†Ñ Î∂àÌà¨Î™Ö
                child.material.depthWrite = true;     // ÍπäÏù¥ Î≤ÑÌçº ÌôúÏÑ±Ìôî ‚Üí ÎÇ¥Î∂Ä ÏïàÎ≥¥ÏûÑ
                child.material.side = THREE.FrontSide; // ÏùºÎ∞òÏ†ÅÏúºÎ°úÎäî FrontSideÎßå
              }
              child.userData.label = filename.replace('.obj', '').replace('segment_', '');
              threeMeshes.push(child);
            });

            loadedObjects.push(object);
            scene.add(object);
            loadedCount++;

            // Î™®Îì† obj Î°úÎìú ÏôÑÎ£å ÌõÑ Ï§ëÏã¨ Ï†ïÎ†¨
            if (loadedCount === objFiles.length) {
              const fullBox = new THREE.Box3();
              loadedObjects.forEach(obj => fullBox.expandByObject(obj));

              const center = new THREE.Vector3();
              fullBox.getCenter(center);

              loadedObjects.forEach(obj => obj.position.sub(center));

              camera.lookAt(0, 0, 0);
              controls.target.set(0, 0, 0);
              controls.update();

              animate();
              renderThreeMeshListUI(threeMeshes);
            }
          });
        });
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        light.position.copy(camera.position); // Ïπ¥Î©îÎùºÏôÄ Í∞ôÏù¥ ÏõÄÏßÅÏù¥Í≤å
        renderer.render(scene, camera);
      }
    }
   

    function createMeshControlRow(mesh) {
      const label = mesh.userData.label || mesh.name || "Mesh";

      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.marginBottom = '8px';

      // üëÅÔ∏è ÏïÑÏù¥ÏΩò
      const eye = document.createElement('span');
      eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
      eye.style.cursor = 'pointer';
      eye.style.fontSize = '20px';
      eye.onclick = () => {
        mesh.visible = !mesh.visible;
        eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
      };

      // ÏÉâÏÉÅ Î∞ïÏä§
      const color = mesh.material?.color || new THREE.Color(0.5, 0.5, 0.5);
      const colorBox = document.createElement('span');
      colorBox.style.display = 'inline-block';
      colorBox.style.width = '24px';
      colorBox.style.height = '24px';
      colorBox.style.margin = '0 10px';
      colorBox.style.background = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
      colorBox.style.border = '1px solid #aaa';
      colorBox.style.borderRadius = '4px';

      // Î†àÏù¥Î∏î
      const name = document.createElement('span');
      name.innerText = label;
      name.style.minWidth = '80px';
      name.style.fontSize = '14px';

      // Ïä¨ÎùºÏù¥Îçî
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = 0;
      slider.max = 1;
      slider.step = 0.01;
      slider.value = mesh.material.opacity ?? 1;
      slider.style.margin = '0 6px';
      slider.style.flex = '1';

      // Í∞í ÌëúÏãú
      const value = document.createElement('span');
      value.innerText = slider.value;
      value.style.width = '32px';
      value.style.textAlign = 'right';

      slider.oninput = (e) => {
        const val = parseFloat(e.target.value);
        mesh.material.opacity = val;
        value.innerText = val.toFixed(2);
      };

      // Ï°∞Î¶Ω
      row.appendChild(eye);
      row.appendChild(colorBox);
      row.appendChild(name);
      row.appendChild(slider);
      row.appendChild(value);

      return row;
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh) => {
        if (!mesh.material) return; // material ÏóÜÎäî Í≤ΩÏö∞ Î¨¥Ïãú

        const labelText = mesh.userData.label || mesh.name;
        const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);
        const opacity = mesh.material.opacity ?? 1;

        const row = document.createElement('div');
        meshListDiv.appendChild(row);
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
        };

        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.margin = '0 10px';
        colorBox.style.background = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`;
        colorBox.style.border = '1px solid #aaa';

        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '16px';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        slider.value = opacity;
        slider.style.width = '80px';

        const sliderValue = document.createElement('span');
        sliderValue.innerText = opacity.toFixed(2);
        sliderValue.style.marginLeft = '6px';
        sliderValue.style.fontSize = '12px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          mesh.material.opacity = val;
          sliderValue.innerText = val.toFixed(2);
        };

        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);

        labelContainer.appendChild(label);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }
  </script> -->

  <script type="module">
    import * as niivue from '../dist/index.js'; // ÎòêÎäî CDN ÏÇ¨Ïö©

    let nvRender; // Ï†ÑÏó≠ ÏÑ†Ïñ∏

    let nvMulti = null;
    const preloadCache = {};


    async function initNiivueMultiViewer(niiUrl, nrrdUrl) {
      // 1. LUT ÎØ∏Î¶¨ ÏÉùÏÑ± (ÏÑ∏Í∑∏Î®ºÌä∏Ïö©)
      const { segCmap, labelLUT } = await loadColormapAndLUT(nrrdUrl);

      // 2. Î≥ºÎ•® Î¶¨Ïä§Ìä∏ ÏÉùÏÑ±
      const volumeList = [
        { url: niiUrl, colormap: 'gray', opacity: 1 },
        { url: nrrdUrl, colormap: 'seg', cal_min: labelLUT.min, cal_max: labelLUT.max, opacity: 0.5 }
      ];

      // 3. Î©ÄÌã∞ÌîåÎ†àÏù∏ Î∑∞Ïñ¥ ÏÉùÏÑ±
      const nvMulti = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.MULTIPLANE,
        dragAndDropEnabled: false,
        isOrientCube: true,
        backColor: [0, 0, 0, 1],
        logLevel: "none"
      });

      await nvMulti.attachTo("canvasMulti");
      await nvMulti.loadVolumes(volumeList);

      // 4. flip/LUT ÌõÑ drawScene (Î∞òÎìúÏãú volumeListÍ∞Ä Î°úÎìúÎêú ÌõÑ Ï†ÅÏö©)
      flipVolumeX(nvMulti.volumes[0]);
      flipVolumeX(nvMulti.volumes[1]);
      nvMulti.volumes[1].lut = labelLUT.lut;
      nvMulti.volumes[1].cal_min = labelLUT.min;
      nvMulti.volumes[1].cal_max = labelLUT.max;
      nvMulti.updateGLVolume();
      nvMulti.drawScene();
    }

    async function initNiivueViewers() {
      nvRender = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.RENDER,
        dragAndDropEnabled: false,
        isOrientCube: true,
        show3Dcrosshair: false,
        backColor: [0.5, 0.5, 1, 1],
        gradientOpacity: 0.3,
        logLevel: "none"
      });

      await nvRender.attachTo("canvasRender");
      nvRender.setSliceType(nvRender.sliceTypeRender);
    }

    const convertBtn = document.getElementById("convertBtn");
    const nrrdInput = document.getElementById("nrrdInput");
    let colorMap = {};
    convertBtn.addEventListener("click", async () => {
      if (!nrrdInput.files.length) {
        alert("NRRD ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî");
        return;
      }

      const file = nrrdInput.files[0];
      const formData = new FormData();
      formData.append("file", file);
      formData.append("folder", "temp123"); // optional

      try {
        status.textContent = "OBJ Î≥ÄÌôò Ï§ë...";
        const res = await fetch("http://127.0.0.1:5000/nrrd-to-obj", {
          method: "POST",
          body: formData
        });

        if (!res.ok) throw new Error("ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù");
        const json = await res.json();
        if (!json.success || !json.objUrls.length) throw new Error("Î≥ÄÌôò Ïã§Ìå®");


        const urlCT = '../images/CTLiver.nii.gz';
        const urlSeg = '../images/CTLiverSegmentation.nrrd';
        // Î≥ºÎ•® Î¶¨Ïä§Ìä∏ Ï§ÄÎπÑ
        await initNiivueMultiViewer(urlCT, urlSeg);

        // 1. Î©îÏâ¨ Î¶¨Ïä§Ìä∏ Ï§ÄÎπÑ
        const meshList = json.objUrls.map(url => ({
          url: "http://127.0.0.1:5000" + url,
          visible: true
        }));

        // 2. .mtl ÌååÏùº ÌååÏã±Ìï¥ÏÑú ÏÉâÏÉÅ Îß§Ìïë
        const mtlUrl = "http://127.0.0.1:5000" + json.mtlUrl;

        // // 3. Î∑∞Ïñ¥ Ï¥àÍ∏∞Ìôî Î∞è Î©îÏâ¨ Î°úÎìú
        // colorMap = await parseMtlFile(mtlUrl);
        // await initNiivueViewers();
        // await nvRender.loadMeshes(meshList);

        // applyMeshColors(nvRender.meshes, colorMap, nvRender);

        // // 4. Î©îÏâ¨ Î∂àÎü¨Ïò§Í∏∞ ÌõÑ UI Í∑∏Î¶¨Í∏∞
        // renderMeshListUI();



        // 1. MTL ÌååÏã± Î∞è Î∑∞Ïñ¥/Î©îÏâ¨ Î°úÎî©
        colorMap = await parseMtlFile(mtlUrl);
        await initNiivueViewers();
        await nvRender.loadMeshes(meshList);

        nvRender.meshes.forEach((mesh, idx) => {
          const matName = mesh.name.replace('.obj', '');
          const rgb = colorMap[matName] || [255, 0, 0];
          mesh.rgba255 = [rgb[0], rgb[1], rgb[2], 80]; // 0~255 (ex: 80=ÏïΩ 0.31)
          mesh.blend = true; // Î¨¥Ï°∞Í±¥ true
          mesh.meshShaderIndex = 0; // Matte, 5(Hemispheric), 11(Toon) Îì± Ï∂îÏ≤ú
          mesh.updateMesh(nvRender.gl);
        });

        // ÍπäÏù¥ ÌÖåÏä§ÌåÖ ÏÑ§Ï†ï ÌôïÏù∏
        nvRender.gl.enable(nvRender.gl.DEPTH_TEST);
        nvRender.gl.depthFunc(nvRender.gl.LEQUAL);
        nvRender.drawScene();
        renderMeshListUI();

        window.nvRender = nvRender; // Ï†ÑÏó≠Ïóê Ï†ÄÏû•

        status.textContent = "OBJ ÏãúÍ∞ÅÌôî Î∞è ÏÉâÏÉÅ Îß§Ìïë ÏôÑÎ£å";
      } catch (err) {
        console.error(err);
        status.textContent = "Ïò§Î•ò Î∞úÏÉù: " + err.message;
      }
    });

    function applyMeshColors(meshes, colorMap, nvRender) {
      const INITIAL_OPACITY = 0.1;

      meshes.forEach(mesh => {
        mesh.blend = true; // Ìï≠ÏÉÅ ÏºúÏ§å (Î∞òÌà¨Î™Ö Ìö®Í≥º)
        mesh.opacity = INITIAL_OPACITY; // (ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨Ïö©)
        // ÏÉâÏÉÅ Ï†ïÏùò
        const matName = mesh.name.replace('.obj', '');
        let rgba;
        if (colorMap[matName]) {
          rgba = colorMap[matName].slice();
          rgba[3] = Math.round(255 * INITIAL_OPACITY);
        } else {
          rgba = [255, 0, 0, Math.round(255 * INITIAL_OPACITY)];
        }
        mesh.rgba255 = rgba;
        mesh.color = rgba.slice(0, 3).map(x => x / 255);

        mesh.updateMesh(nvRender.gl); // WebGL Í∞±Ïã†!
        // meshShader ÏòµÏÖòÏùÄ ÌïÑÏöîÏãú Ìïú Î≤àÎßå (Î∑∞ Ï†ÑÏ≤¥Ïóê ÎèôÏùºÌïòÍ≤å)
      });
      nvRender.drawScene();
      window.nvRender = nvRender;
    }

    // function applyMeshColors(meshes, colorMap, nvRender) {
    //   meshes.forEach(mesh => {
    //     console.log("üöÄ ~ applyMeshColors ~ mesh:", mesh)

    //     // ÌïÑÏöîÏóê Îî∞Îùº prefix Ï≤òÎ¶¨ Îì± Ï°∞Ï†ï
    //     const matName = mesh.name.replace('.obj', '');

    //     if (colorMap[matName]) {
    //       const rgba = colorMap[matName];
    //       mesh.rgba255 = rgba.slice();
    //       mesh.color = rgba.slice(0, 3).map(x => x / 255);
    //       mesh.updateMesh(nvRender.gl);
    //     } else {
    //       // ÏßÑÎã®Ïö©: Îß§Ïπ≠ ÏïàÎêòÎ©¥ Îπ®Í∞ÑÏÉâ
    //       mesh.rgba255 = [255, 0, 0, 255];
    //       mesh.color = [1, 0, 0];
    //       mesh.updateMesh(nvRender.gl);
    //     }
    //   });
    //   nvRender.drawScene();
    // }

    // 3. Î©îÏâ¨ Î¶¨Ïä§Ìä∏ UI Î†åÎçîÎßÅ
    function renderMeshListUI() {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = ''; // Ï¥àÍ∏∞Ìôî

      nvRender.meshes.forEach((mesh, idx) => {
        const matName = mesh.name.replace('.obj', '');
        const rgba = colorMap[matName] || [128, 128, 128, 255];
        const labelText = matName.replace(/^segment_/, '');

        // Ïª®ÌÖåÏù¥ÎÑà
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        // Îàà ÏïÑÏù¥ÏΩò
        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? 'üëÅÔ∏è' : 'üôà';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          // NiivueÎäî mesh.visible = falseÎ©¥ Ìï¥Îãπ meshÍ∞Ä ÏïÑÏòà Ïïà ÎÇòÏò¥
          nvRender.updateGLVolume();
          nvRender.drawScene();
          renderMeshListUI(); // ÏÉÅÌÉú(Îàà ÏïÑÏù¥ÏΩò) Í∞±Ïã†
        };

        // ÏÉâÏÉÅ Î∞ïÏä§
        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.marginLeft = '10px';
        colorBox.style.marginRight = '10px';
        colorBox.style.background = `rgba(${rgba[0]},${rgba[1]},${rgba[2]},1)`;
        colorBox.style.borderRadius = '3px';
        colorBox.style.border = '1px solid #aaa';

        // ÎùºÎ≤® + opacity Ïä¨ÎùºÏù¥Îçî Ïª®ÌÖåÏù¥ÎÑà
        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        // ÎùºÎ≤®
        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '20px';

        // Opacity Ïä¨ÎùºÏù¥Îçî
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        // mesh.opacity Í∞íÏù¥ undefinedÎ©¥ 1Î°ú Ï¥àÍ∏∞Ìôî
        if (typeof mesh.opacity !== 'number') mesh.opacity = 1;
        slider.value = mesh.opacity;

        slider.style.width = '60px';
        slider.title = 'Ìà¨Î™ÖÎèÑ';

        // ÌòÑÏû¨ opacity Í∞í
        const sliderValue = document.createElement('span');
        sliderValue.innerText = mesh.opacity.toFixed(2);
        sliderValue.style.fontSize = '12px';
        sliderValue.style.marginLeft = '8px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          console.log("üöÄ ~ nvRender.meshes.forEach ~ val:", val)
          mesh.opacity = val;
          if (mesh.rgba255) mesh.rgba255[3] = Math.round(255 * val);
          mesh.updateMesh(nvRender.gl);
          nvRender.drawScene();
          sliderValue.innerText = val.toFixed(2);
          console.log(`[slider] ${mesh.name} ${val}`, mesh.rgba255);
        };

        // Ï°∞Î¶Ω
        labelContainer.appendChild(label);
        // ÎùºÎ≤® ÏïÑÎûòÏóê Ïä¨ÎùºÏù¥Îçî + Í∞í ÌëúÏãú
        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }

    // mtlTextÏóêÏÑú newmtl ~ Kd ÏÉâÏÉÅÏùÑ Ï∂îÏ∂úÌï¥ÏÑú colorMap ÎßåÎì§Í∏∞
    function parseMtlColors(mtlText) {
      const colorMap = {};
      let currentMat = null;
      mtlText.split('\n').forEach(line => {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMat = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMat) {
          const [r, g, b] = line.split(' ').slice(1).map(x => Math.round(parseFloat(x) * 255));
          colorMap[currentMat] = [r, g, b, 255];
        }
      });

      return colorMap;
    }

    // .mtl ÌååÏùº ÌååÏã± Ìï®Ïàò
    async function parseMtlFile(mtlUrl) {
      const res = await fetch(mtlUrl);
      if (!res.ok) throw new Error("MTL ÌååÏùº Î°úÎìú Ïã§Ìå®");
      const text = await res.text();
      const lines = text.split('\n');
      const colorMap = {};
      let currentMaterial = null;
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMaterial = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMaterial) {
          const [r, g, b] = line.split(' ').slice(1).map(Number);
          colorMap[currentMaterial] = [r * 255, g * 255, b * 255, 255];
          console.log(`[MTLÌååÏã±] ${currentMaterial} ‚Üí`, colorMap[currentMaterial]);
        }
      }
      return colorMap;
    }

    // const toggleBtn = document.getElementById('toggleOrientation')
    // toggleBtn.addEventListener('click', () => {
    //   orientationVisible = !orientationVisible
    //   nv1.setIsOrientationTextVisible(orientationVisible)
    //   toggleBtn.textContent = orientationVisible ? 'Hide Orientation Text' : 'Show Orientation Text'
    // })


    // import * as niivue from '../dist/index.js';


    const status = document.getElementById('status');
    const folderInput = document.getElementById('folderInput');

    // const urlCT = '../images/CTLiver.nii.gz';
    // const urlCT = await preloadVolume('../images/CTLiver.nii.gz');
    // const urlSeg = '../images/CTLiverSegmentation.nrrd';
    // console.log("Preloaded:", { urlCT, urlSeg });
    // await loadAndVisualize(urlCT, urlSeg);

    folderInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files).filter(f => f.name.endsWith('.dcm'));
      if (!files.length) {
        status.textContent = "DICOM(.dcm) ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.";
        return;
      }

      const fullPath = files[0].webkitRelativePath || '';
      const folderName = fullPath.split('/')[0] || 'default';
      status.textContent = `'${folderName}' ÏóÖÎ°úÎìú Ï§ë...`;

      const formData = new FormData();
      files.forEach(f => formData.append('dicomFiles', f));
      formData.append('folder', folderName);

      try {
        const res = await fetch('http://127.0.0.1:5000/upload-and-infer', {
          method: 'POST',
          body: formData
        });
        const json = await res.json();
        if (!json.success) throw new Error(json.message);

        status.textContent = "ÏãúÍ∞ÅÌôî Ï§ÄÎπÑ Ï§ë...";
        // await loadAndVisualize(json.niiUrl, json.nrrdUrl);

        // const urlCT = '../images/CTLiver.nii.gz';
        // const urlSeg = '../images/CTLiverSegmentation.nrrd';
        // await loadAndVisualize(urlCT, urlSeg);

        status.textContent = "ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.";
      } catch (err) {
        console.error(err);
        status.textContent = "‚ùå Ïò§Î•ò: " + err.message;
      }
    });


    async function preloadVolume(url) {
      if (preloadCache[url]) return preloadCache[url];
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Fetch failed: ${url}`);
      const blob = await response.blob();
      const objectURL = URL.createObjectURL(blob);
      preloadCache[url] = objectURL;
      return objectURL;
    }

    async function loadAndVisualize(urlCT, urlSeg) {
      const { segCmap, labelLUT } = await loadColormapAndLUT(urlSeg);

      const volumeList = [
        { url: urlCT, colormap: 'gray', opacity: 1 },
        {
          url: urlSeg,
          colormap: 'seg',
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 1
        }
      ];

      // ‚úÖ [2Îã®Í≥Ñ] ÌïòÎÇòÏùò Î∑∞Ïñ¥Îßå loadVolumes Ïã§Ìñâ
      const nvAxial = await setupViewer('canvasAxial', niivue.SLICE_TYPE.AXIAL);
      const nvCoronal = await setupViewer('canvasCoronal', niivue.SLICE_TYPE.CORONAL);
      const nvSagittal = await setupViewer('canvasSagittal', niivue.SLICE_TYPE.SAGITTAL);
      const nvRender = await setupViewer('canvasRender', niivue.SLICE_TYPE.RENDER);

      console.time("loadVolumes");
      await nvAxial.loadVolumes(volumeList);
      console.timeEnd("loadVolumes");
      // ‚úÖ [3Îã®Í≥Ñ] ÎÇòÎ®∏ÏßÄ Î∑∞Ïñ¥Îäî loadVolumes ÏóÜÏù¥ volumeListÎ•º ÏßÅÏ†ë ÏÑ§Ï†ï
      await nvCoronal.loadVolumes(volumeList);
      await nvSagittal.loadVolumes(volumeList);
      await nvRender.loadVolumes([volumeList[1]]);

      // ‚úÖ [4Îã®Í≥Ñ] LUT Î∞è flip Ï†ÅÏö© (Í∞ÅÍ∞ÅÏùò volume Í∞ùÏ≤¥Ïóê ÎåÄÌï¥)
      for (const nv of [nvAxial, nvCoronal, nvSagittal]) {
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        nv.updateGLVolume();
        // nv.drawScene();
      }

      nvRender.volumes[0].lut = labelLUT.lut;
      nvRender.volumes[0].cal_min = labelLUT.min;
      nvRender.volumes[0].cal_max = labelLUT.max;
      nvRender.updateGLVolume();
      nvRender.drawScene();

      // ‚úÖ [5Îã®Í≥Ñ] ÏúÑÏπò ÎèôÍ∏∞Ìôî
      for (let nv of [nvAxial, nvCoronal, nvSagittal]) {
        nv.broadcastTo([nvAxial, nvCoronal, nvSagittal, nvRender]);
      }
      // nvAxial.broadcastTo([nvCoronal, nvSagittal, nvRender]); // ÌïòÎÇòÎßå ÎßàÏä§ÌÑ∞Î°ú

      // ‚úÖ [6Îã®Í≥Ñ] Ïª®Ìä∏Î°§Îü¨ Î∞îÏù∏Îî©
      bindRenderControls(nvRender);
    }

    async function loadColormapAndLUT(urlSeg) {
      const segCmap = await makeNiivueColormap(urlSeg);
      niivue.cmapper.addColormap('seg', segCmap);
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, Math.max(...segCmap.I));
      return { segCmap, labelLUT };
    }

    async function makeNiivueColormap(nrrdUrl) {
      const raw = await parseNrrdColorMap(nrrdUrl);
      const I = [], R = [], G = [], B = [], A = [];
      for (let i = 0; i <= 255; i++) {
        if (raw[i]) {
          const { r, g, b, a } = raw[i];
          R.push(r); G.push(g); B.push(b); A.push(a); I.push(i);
        } else {
          R.push(0); G.push(0); B.push(0); A.push(0); I.push(i);
        }
      }
      return { I, R, G, B, A };
    }

    async function parseNrrdColorMap(urlSeg) {
      let text = await fetch(urlSeg).then(r => r.text());
      text = text
        .replace(/^segment(\d+)_color:=/gim, 'Segment$1_Color:=')
        .replace(/^segment(\d+)_labelvalue:=/gim, 'Segment$1_LabelValue:=')
        .split('\n').filter(line =>
          !/^segment\d+_(name|nameautogenerated|extent|id|layer|tags|colorautogenerated):=/i.test(line) &&
          !/^segmentation_/i.test(line)
        ).join('\n');

      const rawColor = {}, rawLabel = {};
      const reColor = /^Segment(\d+)_Color:=\s*([\d\s.]+)$/i;
      const reLabel = /^Segment(\d+)_LabelValue:=\s*(\d+)$/i;

      for (const line of text.split('\n')) {
        let m;
        if ((m = reColor.exec(line))) rawColor[m[1]] = m[2].trim().split(/\s+/).map(x => Math.round(+x * 255));
        if ((m = reLabel.exec(line))) rawLabel[m[1]] = +m[2];
      }

      const cmap = {};
      for (const idx in rawColor) {
        const lbl = rawLabel[idx];
        if (lbl !== undefined) {
          const [r, g, b] = rawColor[idx];
          cmap[lbl] = { r, g, b, a: 255 };
        }
      }
      if (!cmap[0]) cmap[0] = { r: 0, g: 0, b: 0, a: 0 };
      return cmap;
    }

    async function initViewers(viewConfigs) {
      const viewers = {};
      for (const { id, type } of viewConfigs) {
        viewers[id] = await setupViewer(id, type);
      }
      return viewers;
    }

    async function setupViewer(canvasId, sliceType) {
      const defaults = {
        backColor: [0, 0, 0, 1],
        show3Dcrosshair: true,
        logLevel: 'none',
        dragAndDropEnabled: false
      };
      if (sliceType === niivue.SLICE_TYPE.RENDER) {
        defaults.gradientOpacity = 0.3;
        defaults.backColor = [0.5, 0.5, 1, 1];
      }
      const nv = new niivue.Niivue(defaults);
      await nv.attachTo(canvasId);
      nv.setSliceType(sliceType);
      nv.opts.isOrientCube = true;
      return nv;
    }

    async function loadVolumesToSliceViews(viewers, volumeList, labelLUT) {
      for (let nv of viewers) {
        await nv.loadVolumes(volumeList);
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        // nv.updateGLVolume();
        nv.drawScene();
      }
    }

    function flipVolumeX(volume) {
      const dims = volume.dimsRAS;
      const xSize = dims[1], ySize = dims[2], zSize = dims[3];
      const flipped = new volume.img.constructor(volume.img.length);

      const sliceSize = xSize * ySize;
      for (let z = 0; z < zSize; z++) {
        const offsetZ = z * sliceSize;
        for (let y = 0; y < ySize; y++) {
          const rowOffset = offsetZ + y * xSize;
          for (let x = 0; x < xSize; x++) {
            const src = rowOffset + x;
            const dst = rowOffset + (xSize - 1 - x);
            flipped[dst] = volume.img[src];
          }
        }
      }
      volume.img = flipped;
    }

    async function loadVolumesToRenderView(nv, urlSeg, labelLUT) {
      await nv.loadVolumes([{
        url: urlSeg,
        colormap: 'seg',
        cal_min: labelLUT.min,
        cal_max: labelLUT.max,
        opacity: 1
      }]);
    }

    function bindRenderControls(nvRender) {
      // gradientOpacity.oninput = function () {
      //   nvRender.setGradientOpacity(this.value * 0.1);
      // };
      // illumination.oninput = function () {
      //   nvRender.setVolumeRenderIllumination(this.value * 0.1);
      // };
      // gradientOrder.onchange = function () {
      //   nvRender.opts.gradientOrder = parseInt(this.value);
      //   nvRender.updateGLVolume();
      // };
    }
  </script>

  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
    }

    header {
      width: 100vw;
      height: 56px;
      /* ÌïÑÏöîÏóê Îî∞Îùº 40~80px */
      min-height: 40px;
      background: #fff;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #mainLayout {
      display: flex;
      width: 100vw;
      height: calc(100vh - 56px);
      /* header ÎÜíÏù¥ÎßåÌÅº Î∫å */
      overflow: hidden;
    }

    #meshSidebar {
      width: 220px;
      background: #fff;
      border-right: 1px solid #ddd;
      padding: 10px 0 10px 10px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
    }

    #viewerArea {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-width: 1184px;
    }

    #topHalf,
    #bottomHalf {
      width: 100%;
      height: 50%;
    }

    #threeCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }
  </style>
</body>

</html>