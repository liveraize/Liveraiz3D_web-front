<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
</head>

<body>
  <header>
    <label for="sliceType">View</label>
    <select id="sliceType">
      <option value="0">Axial</option>
      <option value="1">Coronal</option>
      <option value="2">Sagittal</option>
      <option value="4">Render</option>
      <option value="3" selected>A+C+S+R</option>
    </select>
    <label for="controller">Broadcast</label>
    <select id="controller">
      <option value="0">Independent</option>
      <option value="1" selected>Top Controls Bottom</option>
      <option value="2">Bottom Controls Top</option>
      <option value="3">Bidirectional</option>
    </select>
    <label for="dragMode">Drag</label>
    <select id="dragMode">
      <option value="contrast" selected>contrast</option>
      <option value="measurement">measurement</option>
      <option value="pan">pan/zoom</option>
      <option value="none">none</option>
    </select>
    <label for="gradientOpacity">Gradient Opacity</label>
    <input type="range" min="0" max="10" value="0" class="slider" id="gradientOpacity">
    <label for="gradientOrder">Gradient Order</label>
    <select id="gradientOrder">
      <option value="1" selected>1</option>
      <option value="2">2</option>
    </select>
    <label for="illumination">Illumination</label>
    <input type="range" min="0" max="10" value="0" class="slider" id="illumination">
  </header>

  <main id="viewerGrid">
    <canvas id="canvasAxial"></canvas>
    <canvas id="canvasRender"></canvas>
    <canvas id="canvasCoronal"></canvas>
    <canvas id="canvasSagittal"></canvas>
  </main>

  <script type="module">
    import * as niivue from '../dist/index.js';

    const urlCT = '../images/CTLiver.nii.gz';
    const urlSeg = '../images/CTLiverSegmentation.nrrd';

    const { segCmap, labelLUT } = await loadColormapAndLUT(urlSeg);

    const volumeList = [
      { url: urlCT, colormap: 'gray', opacity: 1 },
      {
        url: urlSeg,
        colormap: 'seg',
        cal_min: labelLUT.min,
        cal_max: labelLUT.max,
        opacity: 1
      }
    ];

    const nvAxial = await setupViewer('canvasAxial', niivue.SLICE_TYPE.AXIAL);
    const nvCoronal = await setupViewer('canvasCoronal', niivue.SLICE_TYPE.CORONAL);
    const nvSagittal = await setupViewer('canvasSagittal', niivue.SLICE_TYPE.SAGITTAL);
    const nvRender = await setupViewer('canvasRender', niivue.SLICE_TYPE.RENDER);

    // 볼륨 로드 및 적용
    await loadVolumesToSliceViews([nvAxial, nvCoronal, nvSagittal], volumeList, labelLUT);
    await loadVolumesToRenderView(nvRender, urlSeg, labelLUT);

    // UI 이벤트 핸들러 바인딩
    bindRenderControls(nvRender);

    // await loadDemoMesh(nvRender);

    // 위치 동기화
    for (let nv of [nvAxial, nvCoronal, nvSagittal]) {
      nv.broadcastTo([nvAxial, nvCoronal, nvSagittal, nvRender]);
    }

    /*
    async function loadDemoMesh(nvRender) {
      await nvRender.loadMeshes([
        {
          url: '../images/HCC_MR_PP_Sample.obj',
          rgba255: [222, 164, 164, 255],
          opacity: 0.5 // 이 값이 1이면 XRay 효과가 거의 없음
        }
      ]);
    }
    */

    // 아래 함수는 XRay 슬라이더와 메시에 적용하는 기능을 바인딩하는 함수.
    // 사용 시 document에 #xraySlider가 존재.
    // 현재 사용되지 않으므로 주석 상태로 유지.

    /*
    function bindXRayControl(nvRender) {
      document.getElementById("xraySlider").addEventListener("input", function () {
        const xrayValue = parseFloat(this.value);
    
        // XRay 적용
        nvRender.opts.meshXRay = xrayValue;
    
        // 각 메시 오브젝트에 수동 적용
        if (nvRender.meshes.length > 0) {
          nvRender.meshes[0].xray = xrayValue;
        }
    
        nvRender.drawScene();
      });
    }
    */

    // 아래 함수는 메시의 중심 좌표를 기준으로 RenderView 카메라 위치를 초기화합니다.
    // 메시가 로드된 이후 수동 호출이 필요합니다. 사용하지 않을 경우 주석 유지.

    /*
    function centerRenderView(nv) {
      if (!nv.meshes || nv.meshes.length === 0) {
        console.warn("No mesh loaded yet");
        return;
      }
    
      const mesh = nv.meshes[0];
    
      // bounds가 없을 경우 extents를 기반으로 수동 생성
      if (!mesh.bounds && mesh.extentsMin && mesh.extentsMax) {
        mesh.bounds = [
          mesh.extentsMin[0], mesh.extentsMax[0],
          mesh.extentsMin[1], mesh.extentsMax[1],
          mesh.extentsMin[2], mesh.extentsMax[2],
        ];
        console.log("mesh.bounds generated from extents:", mesh.bounds);
      }
    
      if (!mesh.bounds || mesh.bounds.length !== 6) {
        console.warn("mesh.bounds is invalid", mesh);
        return;
      }
    
      const bounds = mesh.bounds;
      const centerX = (bounds[0] + bounds[1]) / 2;
      const centerY = (bounds[2] + bounds[3]) / 2;
      const centerZ = (bounds[4] + bounds[5]) / 2;
      nv.scene.meshCenter = [centerX, centerY, centerZ];
    
      const dx = bounds[1] - bounds[0];
      const dy = bounds[3] - bounds[2];
      const dz = bounds[5] - bounds[4];
      const maxDim = Math.max(dx, dy, dz);
    
      nv.scene.renderAzimuth = 0;
      nv.scene.renderElevation = 0;
      nv.scene.renderDistance = maxDim * 1.5;
    
      // 회전 중심을 메시 중심으로 설정
      nv.scene.crosshairPos = [...nv.scene.meshCenter];
      nv.setCrosshairLocation(nv.scene.meshCenter);
      nv.drawScene();
    }
    */

    async function initViewers(viewConfigs) {
      const viewers = {};
      for (const { id, type } of viewConfigs) {
        viewers[id] = await setupViewer(id, type);
      }
      return viewers;
    }

    // segmentation 색상맵 및 LUT 생성
    async function loadColormapAndLUT(urlSeg) {
      const segCmap = await makeNiivueColormap(urlSeg);
      niivue.cmapper.addColormap('seg', segCmap);
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, Math.max(...segCmap.I));
      return { segCmap, labelLUT };
    }

    // 슬라이스 뷰어에 볼륨 로딩 및 설정
    async function loadVolumesToSliceViews(viewers, volumeList, labelLUT) {
      for (let nv of viewers) {
        await nv.loadVolumes(volumeList);
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        nv.updateGLVolume();
        nv.drawScene();
      }
    }

    // Render 뷰어에 segmentation 볼륨 로딩
    async function loadVolumesToRenderView(nvRender, urlSeg, labelLUT) {
      await nvRender.loadVolumes([{
        url: urlSeg,
        colormap: 'seg',
        cal_min: labelLUT.min,
        cal_max: labelLUT.max,
        opacity: 1
      }]);
    }

    // UI 슬라이더 이벤트 핸들러 바인딩
    function bindRenderControls(nvRender) {
      gradientOpacity.oninput = function () {
        nvRender.setGradientOpacity(this.value * 0.1);
      };
      illumination.oninput = function () {
        nvRender.setVolumeRenderIllumination(this.value * 0.1);
      };
      gradientOrder.onchange = function () {
        nvRender.opts.gradientOrder = parseInt(this.value);
        nvRender.updateGLVolume();
      };
    }

    function handleIntensityChange(data) {
      document.getElementById("intensity").innerHTML = data.string
    }

    // 공통 Niivue 초기화 함수
    async function setupViewer(canvasId, sliceType) {
      let defaults;

      if (canvasId === 'canvasRender') {
        defaults = {
          backColor: [0.5, 0.5, 1, 1],
          show3Dcrosshair: true,
          loglevel: 'debug',
          isRuler: true,
          gradientOpacity: 0.1,
          onLocationChange: handleIntensityChange,
        }
      } else {
        defaults = {
          backColor: [0, 0, 0, 1],
          show3Dcrosshair: true,
        }
      }

      const nv = new niivue.Niivue(defaults);
      await nv.attachTo(canvasId);
      nv.setSliceType(sliceType);
      nv.opts.isOrientCube = true;

      if (canvasId === 'canvasRender') {
        nv.opts.gradientOrder = 1
        nv.setVolumeRenderIllumination(0.3);
      }

      return nv;
    }

    function flipVolumeX(volume) {
      const dims = volume.dimsRAS;
      const xSize = dims[1], ySize = dims[2], zSize = dims[3];
      const flipped = new volume.img.constructor(volume.img.length);
      for (let z = 0; z < zSize; z++) {
        for (let y = 0; y < ySize; y++) {
          for (let x = 0; x < xSize; x++) {
            const srcIdx = x + y * xSize + z * xSize * ySize;
            const flippedX = xSize - x - 1;
            const dstIdx = flippedX + y * xSize + z * xSize * ySize;
            flipped[dstIdx] = volume.img[srcIdx];
          }
        }
      }
      volume.img = flipped;
    }

    // NRRD 헤더 파싱 및 컬러맵 생성
    async function parseNrrdColorMap(urlSeg) {
      let text = await fetch(urlSeg).then(r => r.text());
      text = text
        .replace(/^segment(\d+)_color:=/gim, 'Segment$1_Color:=')
        .replace(/^segment(\d+)_labelvalue:=/gim, 'Segment$1_LabelValue:=')
        .split('\n').filter(line =>
          !/^segment\d+_(name|nameautogenerated|extent|id|layer|tags|colorautogenerated):=/i.test(line) &&
          !/^segmentation_/i.test(line)
        ).join('\n');

      const rawColor = {}, rawLabel = {};
      const reColor = /^Segment(\d+)_Color:=\s*([\d\s.]+)$/i;
      const reLabel = /^Segment(\d+)_LabelValue:=\s*(\d+)$/i;

      for (const line of text.split('\n')) {
        let m;
        if ((m = reColor.exec(line))) rawColor[m[1]] = m[2].trim().split(/\s+/).map(x => Math.round(+x * 255));
        if ((m = reLabel.exec(line))) rawLabel[m[1]] = +m[2];
      }

      const cmap = {};
      for (const idx in rawColor) {
        const lbl = rawLabel[idx];
        if (lbl !== undefined) {
          const [r, g, b] = rawColor[idx];
          cmap[lbl] = { r, g, b, a: 255 };
        }
      }
      if (!cmap[0]) cmap[0] = { r: 0, g: 0, b: 0, a: 0 };
      return cmap;
    }

    async function makeNiivueColormap(nrrdUrl) {
      const raw = await parseNrrdColorMap(nrrdUrl);
      const I = [], R = [], G = [], B = [], A = [];
      for (let i = 0; i <= 255; i++) {
        if (raw[i]) {
          const { r, g, b, a } = raw[i];
          R.push(r); G.push(g); B.push(b); A.push(a); I.push(i);
        } else {
          R.push(0); G.push(0); B.push(0); A.push(0); I.push(i);
        }
      }
      return { I, R, G, B, A };
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #ffffff;
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;

      display: flex;
      flex-wrap: wrap;
      align-items: center;
      padding: 8px;
      gap: 8px;
      background-color: #f0f0f0;
      border-bottom: 1px solid #ccc;
      font-family: sans-serif;
    }

    #viewerGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 0;
      width: 100vw;
      height: calc(100vh - 48px);
      padding-top: 48px;
      /* 헤더 높이만큼 공간 확보 */
    }

    #viewerGrid canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</body>

</html>