<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 56px;
  padding: 0 20px;
  background-color: #111;
  border-bottom: 1px solid #444;
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-sizing: border-box;
">

    <!-- ì¢Œì¸¡ -->


    <!-- ê°€ìš´ë° (ë¡œê³  + í…ìŠ¤íŠ¸) -->
    <div style="
    display: flex;
    align-items: center;
    font-size: 20px;
    font-weight: bold;
    letter-spacing: 1px;
    gap: 10px;
  ">
      <!-- ì‹¬í”Œ ì•„ì´ì½˜ -->
      <div style="
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff4e50, #f9d423);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: white;
      box-shadow: 0 0 4px rgba(0,0,0,0.4);
    ">
        L
      </div>
      <div>Liveraizer</div>
    </div>



    <!-- ìš°ì¸¡ (ë²„íŠ¼) -->
    <div style="display: flex; align-items: center;">
      <button id="undoBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">â†©ï¸</button>

      <button id="editorBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">âœ‚ï¸</button>


    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="file" id="folderInput" webkitdirectory multiple style="
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      font-size: 14px;
    " />
      <span id="status" style="font-size: 14px; color: #ccc;">ì§„í–‰ ì¤‘ ì—†ìŒ</span>
    </div>
  </header>
  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
    </div>
    <div id="viewerArea">
      <div id="viewerContentArea" style="flex:1; display:flex; flex-direction:column;">
        <div id="bottomHalf" style="position: relative;">
          <!-- <canvas id="canvasRender"></canvas> -->
          <div id="labelContainer" style="position:absolute; top:0; left:0; pointer-events:none; z-index:20;"></div>
          <canvas id="threeCanvas"></canvas>
          <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
          <div id="scissorIcon" style="
            position: absolute;
            z-index: 100;
            pointer-events: none;
            display: none;
            font-size: 20px;
          ">âœ‚ï¸</div>
        </div>
        <div id="topHalf">
          <canvas id="canvasMulti"></canvas>
        </div>
      </div>
    </div>
    <div id="volumeTableArea">
      <div id="volumeTableContent"></div>
    </div>
  </div>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
    import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js';

    const threeMeshes = [];
    let hiddenFaces = new Map();
    let undoStack = [];
    let lassoPoints = [];
    let lassoActive = false;
    let editMode = false;
    let lassoCanvas, ctx;
    let selectedMesh = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMesh = null;
    let canvas;

    window.addEventListener("DOMContentLoaded", initThreeJSRenderer);

    function onMouseMove(event) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(threeMeshes, true);
      if (intersects.length > 0) {
        const intersected = intersects[0].object;
        const intersectPoint = intersects[0].point;

        if (hoveredMesh !== intersected) {
          hoveredMesh = intersected;
        }
        showLabel(intersected, intersectPoint);  // â† ë°˜ë“œì‹œ pointë„ ë„˜ê¹€
      } else {
        hoveredMesh = null;
        hideLabel();
      }
    }

    function showLabel(mesh, position) {
      if (editMode) return;
      const labelContainer = document.getElementById('labelContainer');
      labelContainer.innerHTML = '';  // ê¸°ì¡´ ë¼ë²¨ ì œê±°

      const pos = position.clone(); // ì´ì œëŠ” intersect point ê¸°ì¤€ìœ¼ë¡œ í‘œì‹œ
      const vector = pos.project(camera);
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (vector.x + 1) / 2 * rect.width;
      const y = (-vector.y + 1) / 2 * rect.height;

      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.transform = `translate(-50%, -50%)`;
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.padding = '2px 6px';
      div.style.background = 'rgba(0,0,0,0.7)';
      div.style.color = '#fff';
      div.style.borderRadius = '4px';
      div.style.fontSize = '12px';
      div.style.fontWeight = 'bold';

      const hex = mesh.material.color.getHex().toString(16).padStart(6, '0');
      div.style.border = `2px solid #${hex}`;

      div.innerText = mesh.userData.label || mesh.name;

      labelContainer.appendChild(div);
    }

    function hideLabel() {
      const labelContainer = document.getElementById('labelContainer');
      labelContainer.innerHTML = '';  // ë¼ë²¨ ì œê±°
    }

    function toScreen(pos, camera, canvas) {
      const vector = pos.clone().project(camera);
      const rect = canvas.getBoundingClientRect();
      return {
        x: (vector.x + 1) / 2 * rect.width,
        y: (-vector.y + 1) / 2 * rect.height
      };
    }

    function isInsideLasso(point) {
      let inside = false;
      for (let i = 0, j = lassoPoints.length - 1; i < lassoPoints.length; j = i++) {
        const xi = lassoPoints[i].x, yi = lassoPoints[i].y;
        const xj = lassoPoints[j].x, yj = lassoPoints[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function drawLassoPath() {
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);

      if (lassoPoints.length < 2) return;

      ctx.beginPath();
      ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
      for (let i = 1; i < lassoPoints.length; i++) {
        ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
      }

      // ì„ ì€ ì—´ë¦° ìƒíƒœë¡œ ê·¸ë¦°ë‹¤ (ë‹«ì§€ ì•ŠìŒ!)
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
    }

    function hideFace(mesh, faceIndex) {
      const geometry = mesh.geometry;
      if (!geometry.index) return;
      const indexAttr = geometry.index;
      console.log(geometry.index instanceof THREE.BufferAttribute);
      indexAttr.setX(faceIndex * 3, 0);
      indexAttr.setX(faceIndex * 3 + 1, 0);
      indexAttr.setX(faceIndex * 3 + 2, 0);
      geometry.index.needsUpdate = true;
    }

    function undoLastHide() {
      const last = undoStack.pop();
      if (!last) return;
      const { mesh, faceIndex, indices } = last;
      const geometry = mesh.geometry;
      geometry.index.setXYZ(faceIndex, indices[0], indices[1], indices[2]);
      geometry.index.needsUpdate = true;
    }
    let scene, camera, controls, light, renderer;
    async function initThreeJSRenderer() {
      canvas = document.getElementById("threeCanvas");
      const loadedObjects = [];
      let loadedCount = 0;

      lassoCanvas = document.getElementById('lassoCanvas');
      ctx = lassoCanvas.getContext('2d');

      lassoCanvas.width = canvas.clientWidth * window.devicePixelRatio;
      lassoCanvas.height = canvas.clientHeight * window.devicePixelRatio;
      lassoCanvas.style.width = canvas.clientWidth + 'px';
      lassoCanvas.style.height = canvas.clientHeight + 'px';
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.z = 400;
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1A1A1A);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      light = new THREE.DirectionalLight(0xffffff, 0.6);
      light.position.set(0, 1, 1);
      scene.add(light);

      controls = new TrackballControls(camera, renderer.domElement);
      controls.rotateSpeed = 5.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.noZoom = false;
      controls.noPan = false;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;

      canvas.addEventListener('mousemove', onMouseMove);

      document.getElementById('editorBtn').addEventListener('click', () => {
        editMode = !editMode;
        canvas.style.cursor = editMode ? 'crosshair' : 'default';
        controls.enabled = !editMode;
        document.getElementById('editorBtn').textContent = editMode ? 'âœ… í¸ì§‘ ì¤‘ (í´ë¦­í•´ì„œ ì¢…ë£Œ)' : 'âœ‚ï¸ ';

        // âœ‚ï¸ ê°€ìœ„ ì•„ì´ì½˜ í‘œì‹œ/ìˆ¨ê¹€
        scissorIcon.style.display = editMode ? 'block' : 'none';

        // í¸ì§‘ ëª¨ë“œ ì¢…ë£Œ ì‹œ ì„  ë° ì  ì´ˆê¸°í™”
        if (!editMode) {
          clearLassoPath();
          lassoPoints = [];
        }
      });

      function clearLassoPath() {
        ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
      }

      function isLassoClosed() {
        return true; // ë‹«íˆëŠ”ì§€ ì•ˆ ë‹«íˆëŠ”ì§€ëŠ” ë” ì´ìƒ ê²€ì‚¬í•˜ì§€ ì•ŠìŒ
      }

      canvas.addEventListener('mousedown', (e) => {
        if (!editMode) return; // í¸ì§‘ ëª¨ë“œì¼ ë•Œë§Œ ë™ì‘

        lassoPoints = [];
        lassoActive = true;
        const rect = lassoCanvas.getBoundingClientRect();
        lassoPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
      });

      const scissorIcon = document.getElementById('scissorIcon');

      canvas.addEventListener('mouseenter', () => {
        if (editMode) {
          scissorIcon.style.display = 'block';
        }
      });

      canvas.addEventListener('mouseleave', () => {
        scissorIcon.style.display = 'none';
      });

      canvas.addEventListener('mousemove', e => {
        if (!editMode) return;

        const rect = canvas.getBoundingClientRect();

        // âœ‚ï¸ ì•„ì´ì½˜ í•­ìƒ ë§ˆìš°ìŠ¤ ë”°ë¼ê°€ê¸°
        scissorIcon.style.left = (e.clientX - rect.left + 10) + 'px';
        scissorIcon.style.top = (e.clientY - rect.top + 10) + 'px';

        // lasso ê·¸ë¦¬ê¸° (lassoActiveì¼ ë•Œë§Œ)
        if (!lassoActive) return;

        lassoPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
        drawLassoPath();
      });

      canvas.addEventListener('mouseup', () => {
        if (!editMode || lassoPoints.length < 3 || !isLassoClosed()) {
          console.warn("âš ï¸ í¸ì§‘ ì·¨ì†Œ: ì„ ì´ ë‹«íˆì§€ ì•ŠìŒ");
          clearLassoPath();
          lassoPoints = [];
          return;
        }

        console.log("âœ… mouseup: í¸ì§‘ ì‹¤í–‰ ì‹œì‘");
        lassoActive = false;

        if (!selectedMesh) {
          alert("í¸ì§‘í•  ë©”ì‰¬ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.");
          clearLassoPath();
          lassoPoints = [];
          lassoActive = false;
          return;
        }

        const mesh = selectedMesh;
        const geometry = mesh.geometry;
        if (!geometry || !geometry.attributes?.position || !geometry.index) {
          console.warn("âš ï¸ geometry ë¬¸ì œ", { geometry });
          clearLassoPath();
          lassoPoints = [];
          return;
        }

        const indexArray = geometry.index.array;
        const position = geometry.attributes.position;
        let hideCount = 0;

        for (let i = 0; i < indexArray.length; i += 3) {
          const a = indexArray[i];
          const b = indexArray[i + 1];
          const c = indexArray[i + 2];

          const vA = new THREE.Vector3().fromBufferAttribute(position, a).applyMatrix4(mesh.matrixWorld);
          const vB = new THREE.Vector3().fromBufferAttribute(position, b).applyMatrix4(mesh.matrixWorld);
          const vC = new THREE.Vector3().fromBufferAttribute(position, c).applyMatrix4(mesh.matrixWorld);

          const screenA = toScreen(vA, camera, canvas);
          const screenB = toScreen(vB, camera, canvas);
          const screenC = toScreen(vC, camera, canvas);

          const inLasso = isInsideLasso(screenA) && isInsideLasso(screenB) && isInsideLasso(screenC);
          if (inLasso) {
            hideFace(mesh, i / 3);
            hideCount++;
          }
        }

        console.log(`ğŸ” ${mesh.userData.label}: ì˜ë¦° face ê°œìˆ˜:`, hideCount);

        clearLassoPath();
        lassoPoints = [];
      });

      document.getElementById("undoBtn").addEventListener('click', undoLastHide);

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      light.position.copy(camera.position);
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const width = canvas.parentElement.clientWidth;
      const height = canvas.parentElement.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh, idx) => {
        if (!mesh.material) return;
        const row = createMeshRowWithControls(mesh, idx);
        meshListDiv.appendChild(row);
      });
    }

    function createMeshRowWithControls(mesh, idx) {
      const labelText = mesh.userData.label || mesh.name || `Mesh ${idx}`;
      const row = document.createElement('div');

      row.classList.add('mesh-row');
      Object.assign(row.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        background: '#1A1A1A',
        borderRadius: '8px',
        padding: '8px 12px',
        marginBottom: '8px',
        cursor: 'pointer',
      });

      // âœ… ì„ íƒëœ ë©”ì‰¬ì¼ ê²½ìš° ê°•ì¡° í‘œì‹œ ì¶”ê°€
      if (selectedMesh === mesh) {
        row.classList.add('selected-row');
      }

      row.onclick = () => {
        selectedMesh = mesh;
        undoStack = [];

        // í•­ìƒ ê¸°ì¡´ ê°•ì¡° ì œê±°
        document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));

        // í¸ì§‘ ëª¨ë“œì¼ ë•Œë§Œ ê°•ì¡°
        if (editMode) {
          row.classList.add('selected-row');
        }
      };

      const left = createLeftLabelSection(mesh, labelText);
      const controlPanel = createVisibilityAndOpacityControl(mesh);

      row.appendChild(left);
      row.appendChild(controlPanel);

      return row;
    }

    function handleMeshSelect(row, mesh, labelText) {
      console.log("âœ… ë¦¬ìŠ¤íŠ¸ì—ì„œ ì„ íƒëœ ë©”ì‰¬:", labelText);
      selectedMesh = mesh;
      undoStack = [];

      // ê¸°ì¡´ ì„ íƒ í•´ì œ
      document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));
      row.classList.add('selected-row');
    }

    function createLeftLabelSection(mesh, labelText) {
      const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);

      const container = document.createElement('div');
      Object.assign(container.style, {
        display: 'flex',
        alignItems: 'center',
        flex: '1',
      });

      const colorBox = document.createElement('div');
      Object.assign(colorBox.style, {
        width: '12px',
        height: '12px',
        borderRadius: '50%',
        background: `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`,
        marginRight: '8px',
      });

      const label = document.createElement('span');
      label.innerText = labelText;
      Object.assign(label.style, {
        color: '#fff',
        fontSize: '14px',
        flex: '1',
      });

      container.appendChild(colorBox);
      container.appendChild(label);

      return container;
    }

    function createVisibilityAndOpacityControl(mesh) {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.justifyContent = 'space-between';
      container.style.gap = '12px';
      container.style.flex = '1';

      // ì™¼ìª½: ìŠ¬ë¼ì´ë” + ìˆ«ì
      const sliderGroup = document.createElement('div');
      sliderGroup.style.display = 'flex';
      sliderGroup.style.alignItems = 'center';
      sliderGroup.style.gap = '8px';

      const initialOpacity = mesh.material.opacity ?? 1;
      mesh.material.opacity = initialOpacity;

      const slider = document.createElement('input');
      Object.assign(slider, {
        type: 'range',
        min: 0,
        max: 1,
        step: 0.01,
        value: initialOpacity,
        title: 'íˆ¬ëª…ë„ ì¡°ì ˆ',
      });
      slider.style.width = '60px';

      const valueText = document.createElement('span');
      valueText.innerText = initialOpacity.toFixed(2);
      valueText.style.fontSize = '12px';
      valueText.style.color = 'white';
      valueText.style.width = '32px';
      valueText.style.textAlign = 'right';

      slider.oninput = (e) => {
        const val = parseFloat(e.target.value);
        mesh.material.opacity = val;
        valueText.innerText = val.toFixed(2);

        if (val < 1.0) {
          Object.assign(mesh.material, {
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.NormalBlending
          });
        } else {
          Object.assign(mesh.material, {
            transparent: false,
            depthWrite: true,
            side: THREE.DoubleSide,
            blending: THREE.NoBlending
          });
        }

        mesh.material.needsUpdate = true;
      };

      sliderGroup.appendChild(slider);
      sliderGroup.appendChild(valueText);

      // ì˜¤ë¥¸ìª½: eye ì•„ì´ì½˜
      const eye = document.createElement('span');
      eye.style.cursor = 'pointer';
      eye.style.fontSize = '12px';
      eye.style.color = 'white';

      const updateIcon = () => {
        eye.innerHTML = mesh.visible
          ? '<i class="fa-regular fa-eye"></i>'
          : '<i class="fa-regular fa-eye-slash"></i>';
      };

      eye.onclick = (e) => {
        e.stopPropagation();
        mesh.visible = !mesh.visible;
        updateIcon();
        light.position.copy(camera.position);
        renderer.render(scene, camera);
      };

      updateIcon();

      container.appendChild(sliderGroup); // ì™¼ìª½
      container.appendChild(eye);         // ì˜¤ë¥¸ìª½

      return container;
    }


    import * as niivue from '../dist/index.js'; // ë˜ëŠ” CDN ì‚¬ìš©

    let nvRender; // ì „ì—­ ì„ ì–¸

    let nvMulti = null;
    const preloadCache = {};


    function renderVolumeTable(volumeRows, containerId = 'volumeTableContent') {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      const totalVolumeCm3 = volumeRows.reduce((sum, row) => sum + (row.volume / 1000), 0);

      const table = document.createElement('table');
      table.style.width = '100%';
      table.style.borderCollapse = 'collapse';
      table.style.fontSize = '14px';

      // Header
      const thead = document.createElement('thead');
      thead.style.backgroundColor = '#01506b';
      thead.style.color = 'white';

      const headerRow = document.createElement('tr');
      ['Label', 'Volume (cmÂ³)', '%'].forEach(col => {
        const th = document.createElement('th');
        th.innerText = col;
        th.style.padding = '8px';
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Body
      const tbody = document.createElement('tbody');
      volumeRows.forEach((row, rowIndex) => {
        const tr = document.createElement('tr');
        tr.style.backgroundColor = rowIndex % 2 === 0 ? '#e1e7ec' : '#f4f6f8';

        const volumeCm3 = row.volume / 1000;  // mmÂ³ â†’ cmÂ³ ë³€í™˜
        const percent = totalVolumeCm3 > 0 ? (volumeCm3 / totalVolumeCm3 * 100).toFixed(1) : '-';

        [row.label, volumeCm3.toFixed(1), percent].forEach(cellData => {
          const cell = document.createElement('td');
          cell.innerText = cellData;
          cell.style.padding = '8px';
          tr.appendChild(cell);
        });

        tbody.appendChild(tr);
      });

      // Total row
      const trTotal = document.createElement('tr');
      trTotal.style.backgroundColor = '#d1e4f4';
      trTotal.style.fontWeight = 'bold';

      const labelCell = document.createElement('td');
      labelCell.innerText = 'Liver';
      labelCell.style.padding = '8px';

      const volumeCellCm3 = document.createElement('td');
      volumeCellCm3.innerText = totalVolumeCm3.toFixed(1);
      volumeCellCm3.style.padding = '8px';

      const percentCell = document.createElement('td');
      percentCell.innerText = '100.0';
      percentCell.style.padding = '8px';

      trTotal.appendChild(labelCell);
      trTotal.appendChild(volumeCellCm3);
      trTotal.appendChild(percentCell);

      tbody.appendChild(trTotal);
      table.appendChild(tbody);
      container.appendChild(table);
    }


    async function isSegmentationNRRD(urlSeg) {
      const text = await fetch(urlSeg).then(r => r.text());
      return /segment_/i.test(text); // â† í‚¤ ì´ë¦„ì— 'segment_' í¬í•¨ë˜ë©´ true
    }


    async function initNiivueMultiViewer(niiUrl, nrrdUrl, labelColorMap) {
      // const isSegmentation = await isSegmentationNRRD(nrrdUrl);
      const isSegmentation = true; // ê°•ì œë¡œ ì²˜ë¦¬

      // window.labelValueToNameMap = {};
      // window.labelNameToLabelValueMap = {};
      // let idx = 1;
      // for (const key of Object.keys(labelColorMap)) {
      //   const label = key.replace(/^segment_/, '');
      //   window.labelValueToNameMap[idx] = label;
      //   window.labelNameToLabelValueMap[label] = idx;
      //   idx++;
      // }

      console.log("isSegmentationNRRD =", isSegmentation);
      console.log("[LOG] labelColorMap = ", labelColorMap);

      const labelValueToNameMap = {};
      const labelNameToLabelValueMap = {};

      Object.keys(labelColorMap).forEach(k => {
        const match = k.match(/Segment(\d+)/i) || k.match(/.*_(\d+)/i);
        if (!match) return;
        const labelValue = parseInt(match[1]);
        const labelName = k;

        labelValueToNameMap[labelValue] = labelName;
        labelNameToLabelValueMap[labelName] = labelValue;
      });

      window.labelValueToNameMap = labelValueToNameMap;
      window.labelNameToLabelValueMap = labelNameToLabelValueMap;

      let volumeList;

      const nvMulti = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.MULTIPLANE,
        dragAndDropEnabled: false,
        isOrientCube: true,
        backColor: [0, 0, 0, 1],
        logLevel: "none"
      });

      await nvMulti.attachTo("canvasMulti");

      const labelColorMap1 = {
        1: [238, 112, 70, 255],
        2: [238, 112, 70, 255],
        3: [218, 108, 110, 255],
        4: [138, 117, 231, 255],
        5: [211, 255, 51, 255],
        6: [255, 147, 77, 255],
        7: [185, 202, 99, 255],
        8: [79, 255, 174, 255],
        9: [193, 157, 255, 255],
        10: [139, 186, 255, 255],
        11: [234, 36, 36, 255],
        12: [95, 170, 127, 255]
      };

      if (isSegmentation) {
        // ì—¬ê¸°ì—ì„œ ì„œë²„ì—ì„œ ë°›ì€ labelColorMap ì‚¬ìš©

        const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap);
        console.log("[LOG] segCmap = ", segCmap);
        niivue.cmapper.addColormap('seg', segCmap);

        const maxLabelValue = Math.max(...Object.keys(labelColorMap)
          .map(k => parseInt(k.replace("Segment", "")))
          .filter(v => !isNaN(v)));

        const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);
        console.log("[LOG] labelLUT = ", labelLUT);
        volumeList = [
          { url: niiUrl, colormap: 'gray', opacity: 1 },
          { url: nrrdUrl, colormap: 'seg', cal_min: labelLUT.min, cal_max: labelLUT.max }
        ];

        await nvMulti.loadVolumes(volumeList);

        // flipVolumeX(nvMulti.volumes[0]);
        // flipVolumeX(nvMulti.volumes[1]);

        nvMulti.volumes[1].lut = labelLUT.lut;
        nvMulti.volumes[1].cal_min = labelLUT.min;
        nvMulti.volumes[1].cal_max = labelLUT.max;
        console.log("ğŸš€ ~ initNiivueMultiViewer ~ labelLUT.lut:", labelLUT.lut)
        // console.log("Label 5 ìƒ‰ìƒ", labelColorMap[5]); // [211, 255, 51, 255]
        console.log("Label 5 ìƒ‰ìƒ", labelLUT.lut.slice(5 * 4, 5 * 4 + 4));
        console.log("ì„¸ê·¸ cmap", segCmap);
        console.log("ì„¸ê·¸ LUT[5]", labelLUT.lut[5]);
        console.log("ë©”ì‰¬ ì´ë¦„ ë¦¬ìŠ¤íŠ¸", scene.children.map(o => o.material?.name));

      } else {
        volumeList = [
          { url: niiUrl, colormap: 'gray', opacity: 1 },
          { url: nrrdUrl, colormap: 'gray', opacity: 0.5 }
        ];

        await nvMulti.loadVolumes(volumeList);

        // flipVolumeX(nvMulti.volumes[0]);
        // flipVolumeX(nvMulti.volumes[1]);
      }

      nvMulti.updateGLVolume();
      nvMulti.drawScene();
    }

    async function initNiivueViewers() {
      nvRender = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.RENDER,
        dragAndDropEnabled: false,
        isOrientCube: true,
        show3Dcrosshair: false,
        backColor: [0.5, 0.5, 1, 1],
        gradientOpacity: 0.3,
        logLevel: "none"
      });

      await nvRender.attachTo("canvasRender");
      nvRender.setSliceType(nvRender.sliceTypeRender);
    }

    const convertBtn = document.getElementById("convertBtn");
    const nrrdInput = document.getElementById("nrrdInput");
    let colorMap = {};


    function applyMeshColors(meshes, colorMap) {
      const INITIAL_OPACITY = 1.0;

      meshes.forEach(mesh => {
        const matName = mesh.material.name.trim();
        const stripped = matName.replace(/^segment_/, '');

        // ê°€ì¥ ê°•ë ¥í•œ í‚¤ ë§¤í•‘ ë¡œì§
        const fallbackColor =
          colorMap[matName] ||
          colorMap[stripped] ||
          colorMap[`segment_${stripped}`] ||
          [255, 0, 0, 255]; // fallback: ë¹¨ê°„ìƒ‰

        console.log(`[ìƒ‰ìƒ ì ìš©] matName=${matName} â†’`, fallbackColor);

        mesh.material.color = new THREE.Color(
          fallbackColor[0] / 255,
          fallbackColor[1] / 255,
          fallbackColor[2] / 255
        );

        mesh.material.transparent = true;
        mesh.material.opacity = INITIAL_OPACITY;
        mesh.material.needsUpdate = true;

        // ë‚´ë¶€ ìƒíƒœ ì €ì¥
        mesh.rgba255 = fallbackColor;
        mesh.color = fallbackColor.slice(0, 3).map(x => x / 255);
      });
    }
    // function applyMeshColors(meshes, colorMap, nvRender) {
    //   meshes.forEach(mesh => {
    //     // í•„ìš”ì— ë”°ë¼ prefix ì²˜ë¦¬ ë“± ì¡°ì •
    //     const matName = mesh.name.replace('.obj', '');

    //     if (colorMap[matName]) {
    //       const rgba = colorMap[matName];
    //       mesh.rgba255 = rgba.slice();
    //       mesh.color = rgba.slice(0, 3).map(x => x / 255);
    //       mesh.updateMesh(nvRender.gl);
    //     } else {
    //       // ì§„ë‹¨ìš©: ë§¤ì¹­ ì•ˆë˜ë©´ ë¹¨ê°„ìƒ‰
    //       mesh.rgba255 = [255, 0, 0, 255];
    //       mesh.color = [1, 0, 0];
    //       mesh.updateMesh(nvRender.gl);
    //     }
    //   });
    //   nvRender.drawScene();
    // }

    // 3. ë©”ì‰¬ ë¦¬ìŠ¤íŠ¸ UI ë Œë”ë§
    function renderMeshListUI() {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = ''; // ì´ˆê¸°í™”

      nvRender.meshes.forEach((mesh, idx) => {
        const matName = mesh.name.replace('.obj', '');
        const rgba = colorMap[matName] || [128, 128, 128, 255];
        const labelText = matName.replace(/^segment_/, '');

        // ì»¨í…Œì´ë„ˆ
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        row.onclick = () => {
          // ê¸°ì¡´ ì„ íƒ í•´ì œ
          document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));

          // ì„ íƒ í‘œì‹œ
          row.classList.add('selected-row');

          // í•´ë‹¹ ë©”ì‰¬ë¥¼ ì„ íƒ
          selectedMesh = mesh;

          // ì„ íƒë˜ì—ˆìŒì„ logë¡œ í™•ì¸
          console.log("âœ… ë¦¬ìŠ¤íŠ¸ì—ì„œ ì„ íƒëœ ë©”ì‰¬:", mesh.name);

          // UndoStack ì´ˆê¸°í™”
          undoStack = [];
        };

        // ëˆˆ ì•„ì´ì½˜
        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          // NiivueëŠ” mesh.visible = falseë©´ í•´ë‹¹ meshê°€ ì•„ì˜ˆ ì•ˆ ë‚˜ì˜´
          nvRender.updateGLVolume();
          nvRender.drawScene();
          renderMeshListUI(); // ìƒíƒœ(ëˆˆ ì•„ì´ì½˜) ê°±ì‹ 
        };

        // ìƒ‰ìƒ ë°•ìŠ¤
        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.marginLeft = '10px';
        colorBox.style.marginRight = '10px';
        colorBox.style.background = `rgba(${rgba[0]},${rgba[1]},${rgba[2]},1)`;
        colorBox.style.borderRadius = '3px';
        colorBox.style.border = '1px solid #aaa';

        // ë¼ë²¨ + opacity ìŠ¬ë¼ì´ë” ì»¨í…Œì´ë„ˆ
        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        // ë¼ë²¨
        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '20px';

        // Opacity ìŠ¬ë¼ì´ë”
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        // mesh.opacity ê°’ì´ undefinedë©´ 1ë¡œ ì´ˆê¸°í™”
        if (typeof mesh.opacity !== 'number') mesh.opacity = 1;
        slider.value = mesh.opacity;

        slider.style.width = '60px';
        slider.title = 'íˆ¬ëª…ë„';

        // í˜„ì¬ opacity ê°’
        const sliderValue = document.createElement('span');
        sliderValue.innerText = mesh.opacity.toFixed(2);
        sliderValue.style.fontSize = '12px';
        sliderValue.style.marginLeft = '8px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          mesh.opacity = val;
          if (mesh.rgba255) mesh.rgba255[3] = Math.round(255 * val);
          mesh.updateMesh(nvRender.gl);
          nvRender.drawScene();
          sliderValue.innerText = val.toFixed(2);
          console.log(`[slider] ${mesh.name} ${val}`, mesh.rgba255);
        };

        // ì¡°ë¦½
        labelContainer.appendChild(label);
        // ë¼ë²¨ ì•„ë˜ì— ìŠ¬ë¼ì´ë” + ê°’ í‘œì‹œ
        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }

    // mtlTextì—ì„œ newmtl ~ Kd ìƒ‰ìƒì„ ì¶”ì¶œí•´ì„œ colorMap ë§Œë“¤ê¸°
    function parseMtlColors(mtlText) {
      const colorMap = {};
      let currentMat = null;
      mtlText.split('\n').forEach(line => {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMat = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMat) {
          const [r, g, b] = line.split(' ').slice(1).map(x => Math.round(parseFloat(x) * 255));
          colorMap[currentMat] = [r, g, b, 255];
        }
      });

      return colorMap;
    }

    // .mtl íŒŒì¼ íŒŒì‹± í•¨ìˆ˜
    async function parseMtlFile(mtlUrl) {
      const res = await fetch(mtlUrl);
      if (!res.ok) throw new Error("MTL íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨");
      const text = await res.text();
      const lines = text.split('\n');
      const colorMap = {};
      let currentMaterial = null;
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMaterial = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMaterial) {
          const [r, g, b] = line.split(' ').slice(1).map(Number);
          colorMap[currentMaterial] = [r * 255, g * 255, b * 255, 255];

          // console.log(`[MTLíŒŒì‹±] ${currentMaterial} â†’`, colorMap[currentMaterial]);
        }
      }
      return colorMap;
    }

    // const toggleBtn = document.getElementById('toggleOrientation')
    // toggleBtn.addEventListener('click', () => {
    //   orientationVisible = !orientationVisible
    //   nv1.setIsOrientationTextVisible(orientationVisible)
    //   toggleBtn.textContent = orientationVisible ? 'Hide Orientation Text' : 'Show Orientation Text'
    // })


    // import * as niivue from '../dist/index.js';


    const status = document.getElementById('status');
    const folderInput = document.getElementById('folderInput');

    // const urlCT = '../images/CTLiver.nii.gz';
    // const urlCT = await preloadVolume('../images/CTLiver.nii.gz');
    // const urlSeg = '../images/CTLiverSegmentation.nrrd';
    // console.log("Preloaded:", { urlCT, urlSeg });
    // await loadAndVisualize(urlCT, urlSeg);

    folderInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files).filter(f => f.name.endsWith('.dcm'));
      if (!files.length) {
        status.textContent = "DICOM(.dcm) íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.";
        return;
      }

      const fullPath = files[0].webkitRelativePath || '';
      // const folderName = Date.now().toString();
      const folderName = document.getElementById('folderInput').files[0].webkitRelativePath.split('/')[0];
      status.textContent = `'${folderName}' ì—…ë¡œë“œ ì¤‘...`;

      const formData = new FormData();
      files.forEach(f => formData.append('dicomFiles', f));
      formData.append('folder', folderName);

      try {
        const res = await fetch('http://127.0.0.1:5000/upload-and-infer-all', {
          method: 'POST',
          body: formData
        });
        const json = await res.json();
        console.log("json:", json);
        if (!json.success) throw new Error(json.message);

        status.textContent = "ì‹œê°í™” ì¤€ë¹„ ì¤‘...";

        const urlCT = "http://127.0.0.1:5000" + json.niiUrl;
        const urlSeg = "http://127.0.0.1:5000" + json.nrrdUrl;
        const labelColorMap = json.labelColorMap;
        await initNiivueMultiViewer(urlCT, urlSeg, labelColorMap);

        const meshList = json.objUrls.map(url => ({
          url: "http://127.0.0.1:5000" + url,
          visible: true
        }));

        const mtlUrl = "http://127.0.0.1:5000" + json.mtlUrl;
        await loadMeshesIntoThreeJS(meshList, mtlUrl, () => {
          const volumeRows = threeMeshes.map(mesh => {
            const volume = computeMeshVolume(mesh);
            return {
              label: mesh.userData.label || mesh.name,
              volume: volume
            };
          });

          const allowedSegments = ["RPS", "RAS", "LMS", "LLS", "Spigelian", "Cancer"];

          const orderedRows = allowedSegments
            .map(label => volumeRows.find(row => row.label === label))
            .filter(row => row && typeof row.volume === 'number' && !isNaN(row.volume));

          renderVolumeTable(orderedRows);
        });
        // await loadAndVisualize(json.niiUrl, json.nrrdUrl);

        // const urlCT = '../images/CTLiver.nii.gz';
        // const urlSeg = '../images/CTLiverSegmentation.nrrd';
        // await loadAndVisualize(urlCT, urlSeg);

        status.textContent = "ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.";
      } catch (err) {
        console.error(err);
        status.textContent = "âŒ ì˜¤ë¥˜: " + err.message;
      }
    });

    function computeMeshVolume(mesh) {
      const geometry = mesh.geometry;
      if (!geometry.isBufferGeometry) return 0;

      const posAttr = geometry.attributes.position;
      const indexAttr = geometry.index;

      let volume = 0.0;

      for (let i = 0; i < indexAttr.count; i += 3) {
        const a = indexAttr.getX(i);
        const b = indexAttr.getX(i + 1);
        const c = indexAttr.getX(i + 2);

        const p1 = new THREE.Vector3().fromBufferAttribute(posAttr, a);
        const p2 = new THREE.Vector3().fromBufferAttribute(posAttr, b);
        const p3 = new THREE.Vector3().fromBufferAttribute(posAttr, c);

        volume += signedVolumeOfTriangle(p1, p2, p3);
      }

      return Math.abs(volume);
    }


    function signedVolumeOfTriangle(p1, p2, p3) {
      return p1.dot(p2.cross(p3)) / 6.0;
    }

    function updateMeshLabels() {
      const labelContainer = document.getElementById('labelContainer');
      labelContainer.innerHTML = '';  // ê¸°ì¡´ label ì´ˆê¸°í™”

      threeMeshes.forEach(mesh => {
        if (!mesh.visible) return;

        const pos = new THREE.Vector3();
        mesh.geometry.computeBoundingBox();
        mesh.geometry.boundingBox.getCenter(pos);
        pos.applyMatrix4(mesh.matrixWorld);

        const vector = pos.clone().project(camera);
        const rect = renderer.domElement.getBoundingClientRect();
        const x = (vector.x + 1) / 2 * rect.width;
        const y = (-vector.y + 1) / 2 * rect.height;

        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.transform = `translate(-50%, -50%)`;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.padding = '2px 6px';
        div.style.background = 'rgba(0,0,0,0.7)';
        div.style.color = '#fff';
        div.style.borderRadius = '4px';
        div.style.fontSize = '12px';
        div.style.fontWeight = 'bold';
        div.style.border = `2px solid #${Math.floor(mesh.material.color.getHex()).toString(16).padStart(6, '0')}`;
        div.innerText = mesh.userData.label || mesh.name;

        labelContainer.appendChild(div);
      });
    }

    async function loadMeshesIntoThreeJS(meshList, mtlUrl, onComplete) {
      // ê¸°ì¡´ ë©”ì‰¬ ì‚­ì œ
      threeMeshes.forEach(mesh => {
        scene.remove(mesh.parent);  // parent (Object3D) í†µì§¸ë¡œ ì‚­ì œ
      });

      threeMeshes.length = 0;
      colorMap = await parseMtlFile(mtlUrl);
      console.log("âœ… colorMap loaded", colorMap);

      const mtlPath = mtlUrl.substring(0, mtlUrl.lastIndexOf("/") + 1);
      const mtlLoader = new MTLLoader();
      mtlLoader.setResourcePath(mtlPath);
      mtlLoader.setPath(mtlPath);

      mtlLoader.load("segments.mtl", materials => {
        materials.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(mtlPath);

        const loadedObjects = [];
        let loadedCount = 0;

        meshList.forEach(mesh => {
          const filename = mesh.url.split("/").pop();

          objLoader.load(filename, object => {
            // object.scale.x *= -1; ë©”ì‹œ ë°˜ì „
            object.traverse(child => {
              if (child instanceof THREE.Mesh) {
                child.geometry = BufferGeometryUtils.mergeVertices(child.geometry);
                child.geometry.computeVertexNormals();

                if (!child.name || child.name.trim() === '') {
                  child.name = child.material?.name || 'segment_UNKNOWN';
                }

                const matName = child.material.name.trim();
                const fallbackColor = colorMap[matName] || [128, 128, 128, 255];

                console.log("ğŸ” Loaded mesh name:", child.name);
                console.log("ğŸ” Material name:", matName);
                console.log("ğŸ” Available labelColorMap keys:", Object.keys(colorMap));
                console.log(`[ìƒ‰ìƒ ì ìš©] matName=${matName}, fallbackColor=`, fallbackColor);

                const color = new THREE.Color(
                  fallbackColor[0] / 255,
                  fallbackColor[1] / 255,
                  fallbackColor[2] / 255
                );

                child.material = new THREE.MeshPhongMaterial({
                  color: color,
                  shininess: 40,
                  specular: new THREE.Color(0.5, 0.5, 0.5),
                  side: THREE.DoubleSide,
                  transparent: true,
                  opacity: 1.0,
                  depthWrite: true,
                  blending: THREE.NormalBlending
                });

                child.userData.label = filename.replace('.obj', '').replace('segment_', '');
                threeMeshes.push(child);
              }
            });

            loadedObjects.push(object);
            scene.add(object);  // ê¸°ì¡´ ì‚­ì œ í›„ ìƒˆë¡œìš´ objectë§Œ ì¶”ê°€
            loadedCount++;

            if (loadedCount === meshList.length) {
              const fullBox = new THREE.Box3();
              loadedObjects.forEach(obj => fullBox.expandByObject(obj));
              const center = new THREE.Vector3();
              fullBox.getCenter(center);

              loadedObjects.forEach(obj => obj.position.sub(center));

              camera.up.set(0, 1, 0);

              const size = new THREE.Vector3();
              fullBox.getSize(size);

              const maxSize = Math.max(size.x, size.y, size.z);
              const fov = camera.fov * (Math.PI / 180);
              const distance = maxSize / (2 * Math.tan(fov / 2));

              const paddingFactor = 1.2;
              camera.position.set(distance * -1.2, distance * 0.4, distance * 1.2);
              camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 12);

              camera.lookAt(0, 0, 0);
              controls.target.set(0, 0, 0);
              controls.update();

              animate();
              renderThreeMeshListUI(threeMeshes);

              if (onComplete) onComplete();
            }
          });
        });
      });
    }

    async function preloadVolume(url) {
      if (preloadCache[url]) return preloadCache[url];
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Fetch failed: ${url}`);
      const blob = await response.blob();
      const objectURL = URL.createObjectURL(blob);
      preloadCache[url] = objectURL;
      return objectURL;
    }

    async function loadAndVisualize(urlCT, urlSeg) {
      const { segCmap, labelLUT } = await loadColormapAndLUT(urlSeg);

      const volumeList = [
        { url: urlCT, colormap: 'gray', opacity: 1 },
        {
          url: urlSeg,
          colormap: 'seg',
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 1
        }
      ];

      // âœ… [2ë‹¨ê³„] í•˜ë‚˜ì˜ ë·°ì–´ë§Œ loadVolumes ì‹¤í–‰
      const nvAxial = await setupViewer('canvasAxial', niivue.SLICE_TYPE.AXIAL);
      const nvCoronal = await setupViewer('canvasCoronal', niivue.SLICE_TYPE.CORONAL);
      const nvSagittal = await setupViewer('canvasSagittal', niivue.SLICE_TYPE.SAGITTAL);
      const nvRender = await setupViewer('canvasRender', niivue.SLICE_TYPE.RENDER);

      console.time("loadVolumes");
      await nvAxial.loadVolumes(volumeList);
      console.timeEnd("loadVolumes");
      // âœ… [3ë‹¨ê³„] ë‚˜ë¨¸ì§€ ë·°ì–´ëŠ” loadVolumes ì—†ì´ volumeListë¥¼ ì§ì ‘ ì„¤ì •
      await nvCoronal.loadVolumes(volumeList);
      await nvSagittal.loadVolumes(volumeList);
      await nvRender.loadVolumes([volumeList[1]]);

      // âœ… [4ë‹¨ê³„] LUT ë° flip ì ìš© (ê°ê°ì˜ volume ê°ì²´ì— ëŒ€í•´)
      for (const nv of [nvAxial, nvCoronal, nvSagittal]) {
        // flipVolumeX(nv.volumes[0]);
        // flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        nv.updateGLVolume();
        // nv.drawScene();
      }

      nvRender.volumes[0].lut = labelLUT.lut;
      nvRender.volumes[0].cal_min = labelLUT.min;
      nvRender.volumes[0].cal_max = labelLUT.max;
      nvRender.updateGLVolume();
      nvRender.drawScene();

      // âœ… [5ë‹¨ê³„] ìœ„ì¹˜ ë™ê¸°í™”
      for (let nv of [nvAxial, nvCoronal, nvSagittal]) {
        nv.broadcastTo([nvAxial, nvCoronal, nvSagittal, nvRender]);
      }
      // nvAxial.broadcastTo([nvCoronal, nvSagittal, nvRender]); // í•˜ë‚˜ë§Œ ë§ˆìŠ¤í„°ë¡œ

      // âœ… [6ë‹¨ê³„] ì»¨íŠ¸ë¡¤ëŸ¬ ë°”ì¸ë”©
      bindRenderControls(nvRender);
    }
    // ê¸°ì¡´ ì„ ì–¸ ë¶€ë¶„ì„ ì•„ë˜ ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš”
    function parseNrrdColorMapAndNameMap(nrrdHeader) {
      const colorMap = {};
      const labelValueToNameMap = {};
      const labelNameToLabelValueMap = {};

      for (const key in nrrdHeader) {
        const segmentMatch = key.match(/Segment(\d+)_/i);
        if (!segmentMatch) continue;
        const segmentId = segmentMatch[1];

        const labelValueKey = `Segment${segmentId}_LabelValue`;
        const labelNameKey = `Segment${segmentId}_LabelName`;
        const colorKey = `Segment${segmentId}_Color`;

        const labelValue = parseInt(nrrdHeader[labelValueKey]);
        const labelName = nrrdHeader[labelNameKey]?.trim() || `Segment${segmentId}`;
        const colorValues = nrrdHeader[colorKey]?.split(' ').map(Number) || [0.5, 0.5, 0.5];

        if (!isNaN(labelValue)) {
          labelValueToNameMap[labelValue] = labelName;
          labelNameToLabelValueMap[labelName] = labelValue;

          // ì»¬ëŸ¬ë§µì— ì—¬ëŸ¬ í‚¤ë¡œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ êµ¬ì„±
          colorMap[labelName] = colorValues.map(c => Math.round(c * 255)).concat(255);
          colorMap[`segment_${labelName}`] = colorMap[labelName];
          colorMap[`segment${segmentId}`] = colorMap[labelName];
        }
      }

      return {
        colorMap,
        labelValueToNameMap,
        labelNameToLabelValueMap
      };
    }

    function makeNiivueColormapFromLabelColorMap(labelColorMap) {
      const I = [], R = [], G = [], B = [], A = [];

      const labelMap = {}; // ì„ì‹œ ë³´ê´€ì†Œ

      console.log("ğŸŸ¡ [ë””ë²„ê¹…] ì…ë ¥ëœ labelColorMap í‚¤ ëª©ë¡:", Object.keys(labelColorMap));

      Object.keys(labelColorMap).forEach(k => {
        const match = k.match(/Segment(\d+)/i) || k.match(/.*_(\d+)/i);
        if (!match) {
          console.warn("âš ï¸ [ê²½ê³ ] ë¼ë²¨ ì´ë¦„ì—ì„œ ìˆ«ì ì¶”ì¶œ ì‹¤íŒ¨:", k);
          return;
        }

        const labelValue = parseInt(match[1]);
        const [r, g, b, a] = labelColorMap[k];
        labelMap[labelValue] = [r, g, b, a];

        console.log(`âœ… [ë¼ë²¨ ë§¤í•‘] ${k} â†’ ${labelValue} = [${r}, ${g}, ${b}, ${a}]`);
      });

      for (let i = 0; i <= 255; i++) {
        I.push(i);
        if (labelMap[i]) {
          const [r, g, b, a] = labelMap[i];
          R.push(r);
          G.push(g);
          B.push(b);
          A.push(a);
          console.log(`ğŸ¨ labelValue ${i} ìƒ‰ìƒ ì ìš©: [${r}, ${g}, ${b}, ${a}]`);
        } else {
          R.push(0); G.push(0); B.push(0); A.push(0);
        }
      }

      console.log("ğŸ§© [ì™„ì„±ëœ ì„¸ê·¸ ì»¬ëŸ¬ë§µ]", { I, R: R.slice(0, 16), G: G.slice(0, 16), B: B.slice(0, 16), A: A.slice(0, 16) });

      return { I, R, G, B, A };
    }

    // function makeNiivueColormapFromLabelColorMap(labelColorMap) {
    //   console.log("ğŸš€ ~ makeNiivueColormapFromLabelColorMap ~ labelColorMap:", labelColorMap);
    //   const I = [], R = [], G = [], B = [], A = [];

    //   for (let i = 0; i <= 255; i++) {
    //     I.push(i);

    //     // Segment ìˆ«ìì™€ iê°€ ì¼ì¹˜í•˜ëŠ” í‚¤ë¥¼ ì°¾ìŒ
    //     const key = Object.keys(labelColorMap).find(k => {
    //       const match = k.match(/Segment(\d+)/i);
    //       return match && parseInt(match[1]) === i;
    //     });

    //     console.log("ğŸš€ ~ i:", i, "â†’ key:", key);

    //     if (key) {
    //       const [r, g, b, a] = labelColorMap[key];
    //       R.push(r); G.push(g); B.push(b); A.push(a);
    //     } else {
    //       R.push(0); G.push(0); B.push(0); A.push(0);
    //     }
    //   }

    //   return { I, R, G, B, A };
    // }


    // function makeNiivueColormapFromLabelColorMap(labelColorMap) {
    //   const I = [], R = [], G = [], B = [], A = [];

    //   for (let i = 0; i <= 255; i++) {
    //     I.push(i);
    //     const key = Object.keys(labelColorMap).find(k => {
    //       const match = k.match(/segment_(\D*)?(\d+)/i);
    //       console.log("ğŸš€ ~ key ~ match:", match)
    //       if (!match) return false;
    //       const index = parseInt(match[2]);
    //       return index === i;
    //     });

    //     if (key) {
    //       const [r, g, b, a] = labelColorMap[key];
    //       R.push(r); G.push(g); B.push(b); A.push(a);
    //     } else {
    //       R.push(0); G.push(0); B.push(0); A.push(0);
    //     }
    //   }

    //   return { I, R, G, B, A };
    // }

    async function loadColormapAndLUT(urlSeg) {
      // 1ï¸âƒ£ NRRD í—¤ë” íŒŒì‹±
      const nrrdResponse = await fetch(urlSeg);
      const nrrdText = await nrrdResponse.text();
      const nrrdHeader = parseNrrdHeader(nrrdText);

      // 2ï¸âƒ£ ColorMap / LabelNameMap íŒŒì‹±
      const raw = parseNrrdColorMap(nrrdHeader);
      let { colorMap: nrrdColorMap, labelValueToNameMap, labelNameToLabelValueMap } = parseNrrdColorMapAndNameMap(nrrdHeader);

      // 2-1ï¸âƒ£ ë§Œì•½ labelValueToNameMapì´ ì—†ê±°ë‚˜ ë¹„ì–´ ìˆë‹¤ë©´ ìë™ ìƒì„±
      if (!labelValueToNameMap || Object.keys(labelValueToNameMap).length === 0) {
        console.warn('âš ï¸ labelValueToNameMap ì—†ìŒ â†’ ìë™ ìƒì„± ì‹œë„');
        labelValueToNameMap = {};
        labelNameToLabelValueMap = {};
        let idx = 1;
        for (const key of Object.keys(nrrdColorMap)) {
          const name = key.replace(/^segment_?/, '');
          labelValueToNameMap[idx] = name;
          labelNameToLabelValueMap[name] = idx;
          idx++;
        }
      }

      // 3ï¸âƒ£ Niivueìš© colormap ìƒì„±
      const segCmap = makeNiivueColormap(nrrdHeader);
      niivue.cmapper.addColormap('seg', segCmap);

      const usedLabels = Object.keys(labelColorMap)
        .map(k => parseInt(k.match(/Segment(\d+)/i)?.[1]))
        .filter(v => !isNaN(v));
      const maxLabelValue = Math.max(...usedLabels);

      // 4ï¸âƒ£ LUT ìƒì„±
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);

      // 5ï¸âƒ£ ì „ì—­ ë³€ìˆ˜ ë“±ë¡
      window.labelValueToNameMap = labelValueToNameMap;
      window.labelNameToLabelValueMap = labelNameToLabelValueMap;

      // 6ï¸âƒ£ Three.jsìš© colorMap êµ¬ì„±
      colorMap = {};
      for (const key in labelValueToNameMap) {
        const labelName = labelValueToNameMap[key];
        const fallbackColor =
          nrrdColorMap[`segment${key}`] ||
          nrrdColorMap[`segment_${labelName}`] ||
          nrrdColorMap[labelName] ||
          [128, 128, 128, 255];
        colorMap[labelName] = fallbackColor;
      }

      console.log('âœ… labelValueToNameMap:', labelValueToNameMap);
      console.log('âœ… labelNameToLabelValueMap:', labelNameToLabelValueMap);
      console.log('âœ… Three.js colorMap:', colorMap);

      return { segCmap, labelLUT };
    }

    function makeNiivueColormap(nrrdHeader) {
      const raw = parseNrrdColorMap(nrrdHeader);
      const I = [], R = [], G = [], B = [], A = [];
      for (let i = 0; i <= 255; i++) {
        if (raw[`segment${i}`]) {
          const rgba = raw[`segment${i}`];
          R.push(rgba[0]);
          G.push(rgba[1]);
          B.push(rgba[2]);
          A.push(rgba[3]);
          I.push(i);
        } else {
          R.push(0); G.push(0); B.push(0); A.push(0); I.push(i);
        }
      }
      return { I, R, G, B, A };
    }

    function parseNrrdColorMap(nrrdHeader) {
      const colorMap = {};
      for (const key in nrrdHeader) {
        if (key.match(/Segment\d+_Color/i)) {
          const segmentId = key.match(/Segment(\d+)_Color/i)[1];
          const segmentKey = `segment${segmentId}`; // ë°˜ë“œì‹œ segment1, segment2 ë“±ìœ¼ë¡œ ê³ ì •
          const colorValues = nrrdHeader[key].split(' ').map(Number);
          colorMap[segmentKey] = [
            Math.round(colorValues[0] * 255),
            Math.round(colorValues[1] * 255),
            Math.round(colorValues[2] * 255),
            255
          ];
        }
      }
      return colorMap;
    }

    function parseNrrdHeader(nrrdText) {
      const header = {};
      const lines = nrrdText.split('\n');
      for (let line of lines) {
        line = line.trim();
        if (line === '' || line.startsWith('#')) continue;
        const parts = line.split(':');
        if (parts.length < 2) continue;
        const key = parts[0].trim();
        const value = parts.slice(1).join(':').trim();
        header[key] = value;
      }
      return header;
    }

    async function initViewers(viewConfigs) {
      const viewers = {};
      for (const { id, type } of viewConfigs) {
        viewers[id] = await setupViewer(id, type);
      }
      return viewers;
    }

    async function setupViewer(canvasId, sliceType) {
      const defaults = {
        backColor: [0, 0, 0, 1],
        show3Dcrosshair: true,
        logLevel: 'none',
        dragAndDropEnabled: false
      };
      if (sliceType === niivue.SLICE_TYPE.RENDER) {
        defaults.gradientOpacity = 0.3;
        defaults.backColor = [0.5, 0.5, 1, 1];
      }
      const nv = new niivue.Niivue(defaults);
      await nv.attachTo(canvasId);
      nv.setSliceType(sliceType);
      nv.opts.isOrientCube = true;
      return nv;
    }

    async function loadVolumesToSliceViews(viewers, volumeList, labelLUT) {
      for (let nv of viewers) {
        await nv.loadVolumes(volumeList);
        // flipVolumeX(nv.volumes[0]);
        // flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        // nv.updateGLVolume();
        nv.drawScene();
      }
    }

    function flipVolumeX(volume) {
      const dims = volume.dimsRAS;
      const xSize = dims[1], ySize = dims[2], zSize = dims[3];
      const flipped = new volume.img.constructor(volume.img.length);

      const sliceSize = xSize * ySize;
      for (let z = 0; z < zSize; z++) {
        const offsetZ = z * sliceSize;
        for (let y = 0; y < ySize; y++) {
          const rowOffset = offsetZ + y * xSize;
          for (let x = 0; x < xSize; x++) {
            const src = rowOffset + x;
            const dst = rowOffset + (xSize - 1 - x);
            flipped[dst] = volume.img[src];
          }
        }
      }
      volume.img = flipped;
    }

    async function loadVolumesToRenderView(nv, urlSeg, labelLUT) {
      await nv.loadVolumes([{
        url: urlSeg,
        colormap: 'seg',
        cal_min: labelLUT.min,
        cal_max: labelLUT.max,
        opacity: 1
      }]);
    }

    function bindRenderControls(nvRender) {
      // gradientOpacity.oninput = function () {
      //   nvRender.setGradientOpacity(this.value * 0.1);
      // };
      // illumination.oninput = function () {
      //   nvRender.setVolumeRenderIllumination(this.value * 0.1);
      // };
      // gradientOrder.onchange = function () {
      //   nvRender.opts.gradientOrder = parseInt(this.value);
      //   nvRender.updateGLVolume();
      // };
    }
  </script>

  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
      background: black;
    }

    header {
      width: 100vw;
      height: 56px;
      /* í•„ìš”ì— ë”°ë¼ 40~80px */
      min-height: 40px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #meshSidebar {
      pointer-events: auto;
      z-index: 10;
      flex: 0 1 270px;
      min-width: 150px;
      border-right: 1px solid #ddd;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
      min-width: 270px;
    }

    #topHalf,
    #bottomHalf {
      width: 100%;
      height: 50%;
    }

    #threeCanvas {
      pointer-events: auto;
      /* ë˜ëŠ” all */
      z-index: 1;
      /* sidebarë³´ë‹¤ ë‚®ì•„ì•¼ í´ë¦­ í†µê³¼ */
      width: 100%;
      height: 100%;
      display: block;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 10px;
      box-shadow: 0 0 4px rgba(0, 123, 255, 0.3);
    }

    #mainLayout {
      display: flex;
      flex-direction: row;
      /* ëª…ì‹œì ìœ¼ë¡œ ì¢Œ-ì¤‘-ìš° ë°°ì¹˜ */
      width: 100vw;
      height: calc(100vh - 56px);
      overflow: hidden;
    }

    #viewerArea {
      flex: 1 1 auto;
      /* ë‚¨ëŠ” ê³µê°„ ë‹¤ ì‚¬ìš© */
      min-width: 0;
      /* overflow ë°©ì§€ */
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #volumeTableArea {
      width: 300px;
      background: #000000;
      padding: 16px;
      border-left: 1px solid #ccc;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
      z-index: 1;
    }

    header button,
    header input[type="file"] {
      font-size: 14px;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      margin-right: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    header button:hover,
    header input[type="file"]:hover {
      background-color: #0056b3;
    }

    header button:active,
    header input[type="file"]:active {
      background-color: #004999;
    }

    header #status {
      font-size: 14px;
      color: white;
      margin-left: 12px;
    }

    #volumeTableContent table {
      width: 100%;
      border-collapse: collapse;
      font-size: 15px;
      border: 1px solid #ccc;
    }

    #volumeTableContent thead {
      background-color: #004c7f;
      /* ì¢€ ë” ê¹Šì€ ë¸”ë£¨ */
      color: white;
    }

    #volumeTableContent thead th {
      padding: 10px;
      border-bottom: 1px solid #ccc;
      text-align: left;
    }

    #volumeTableContent tbody tr:nth-child(even) {
      background-color: #f2f6f9;
    }

    #volumeTableContent tbody tr:nth-child(odd) {
      background-color: #e8eff5;
    }

    #volumeTableContent tbody td {
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    #volumeTableContent tbody tr:last-child {
      background-color: #e0f0ff;
      /* Total í–‰ ë°°ê²½ */
      font-weight: bold;
    }

    #volumeTableContent tbody tr:last-child td {
      color: #003366;
    }
  </style>
</body>

</html>