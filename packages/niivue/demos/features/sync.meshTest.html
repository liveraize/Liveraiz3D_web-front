<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 56px;
  padding: 0 20px;
  background-color: #111;
  border-bottom: 1px solid #444;
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-sizing: border-box;
">

    <!-- 좌측 -->


    <!-- 가운데 (로고 + 텍스트) -->
    <div style="
    display: flex;
    align-items: center;
    font-size: 20px;
    font-weight: bold;
    letter-spacing: 1px;
    gap: 10px;
  ">
      <!-- 심플 아이콘 -->
      <div style="
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff4e50, #f9d423);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: white;
      box-shadow: 0 0 4px rgba(0,0,0,0.4);
    ">
        L
      </div>
      <div>Liveraizer</div>
    </div>



    <!-- 우측 (버튼) -->
    <div style="display: flex; align-items: center;">
      <button id="undoBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">↩️</button>

      <button id="editorBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">✂️</button>


    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="file" id="folderInput" webkitdirectory multiple style="
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      font-size: 14px;
    " />
      <span id="status" style="font-size: 14px; color: #ccc;">진행 중 없음</span>
    </div>
  </header>
  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
    </div>
    <div id="viewerArea">
      <div id="viewerContentArea" style="flex:1; display:flex; flex-direction:column;">
        <div id="bottomHalf" style="position: relative;">
          <!-- <canvas id="canvasRender"></canvas> -->
          <div id="labelContainer" style="position:absolute; top:0; left:0; pointer-events:none; z-index:20;"></div>
          <canvas id="threeCanvas"></canvas>
          <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
          <div id="scissorIcon" style="
            position: absolute;
            z-index: 100;
            pointer-events: none;
            display: none;
            font-size: 20px;
          ">✂️</div>
        </div>
        <div id="topHalf">
          <canvas id="canvasMulti"></canvas>
        </div>
      </div>
    </div>
    <div id="volumeTableArea">
      <div id="volumeTableContent"></div>
    </div>
  </div>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
    import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js';

    const threeMeshes = [];
    let hiddenFaces = new Map();
    let undoStack = [];
    let lassoPoints = [];
    let lassoActive = false;
    let editMode = false;
    let lassoCanvas, ctx;
    let selectedMesh = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMesh = null;
    let canvas;

    window.addEventListener("DOMContentLoaded", initThreeJSRenderer);

    function onMouseMove(event) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(threeMeshes, true);
      if (intersects.length > 0) {
        const intersected = intersects[0].object;
        const intersectPoint = intersects[0].point;

        if (hoveredMesh !== intersected) {
          hoveredMesh = intersected;
        }
        showLabel(intersected, intersectPoint);  // ← 반드시 point도 넘김
      } else {
        hoveredMesh = null;
        hideLabel();
      }
    }

    function showLabel(mesh, position) {
      if (editMode) return;
      const labelContainer = document.getElementById('labelContainer');
      labelContainer.innerHTML = '';  // 기존 라벨 제거

      const pos = position.clone(); // 이제는 intersect point 기준으로 표시
      const vector = pos.project(camera);
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (vector.x + 1) / 2 * rect.width;
      const y = (-vector.y + 1) / 2 * rect.height;

      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.transform = `translate(-50%, -50%)`;
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.padding = '2px 6px';
      div.style.background = 'rgba(0,0,0,0.7)';
      div.style.color = '#fff';
      div.style.borderRadius = '4px';
      div.style.fontSize = '12px';
      div.style.fontWeight = 'bold';

      const hex = mesh.material.color.getHex().toString(16).padStart(6, '0');
      div.style.border = `2px solid #${hex}`;

      div.innerText = mesh.userData.label || mesh.name;

      labelContainer.appendChild(div);
    }

    function hideLabel() {
      const labelContainer = document.getElementById('labelContainer');
      labelContainer.innerHTML = '';  // 라벨 제거
    }

    function toScreen(pos, camera, canvas) {
      const vector = pos.clone().project(camera);
      const rect = canvas.getBoundingClientRect();
      return {
        x: (vector.x + 1) / 2 * rect.width,
        y: (-vector.y + 1) / 2 * rect.height
      };
    }

    function isInsideLasso(point) {
      let inside = false;
      for (let i = 0, j = lassoPoints.length - 1; i < lassoPoints.length; j = i++) {
        const xi = lassoPoints[i].x, yi = lassoPoints[i].y;
        const xj = lassoPoints[j].x, yj = lassoPoints[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function drawLassoPath() {
      ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);

      if (lassoPoints.length < 2) return;

      ctx.beginPath();
      ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
      for (let i = 1; i < lassoPoints.length; i++) {
        ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
      }

      // 선은 열린 상태로 그린다 (닫지 않음!)
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
    }

    function hideFace(mesh, faceIndex) {
      const geometry = mesh.geometry;
      if (!geometry.index) return;
      const indexAttr = geometry.index;
      console.log(geometry.index instanceof THREE.BufferAttribute);
      indexAttr.setX(faceIndex * 3, 0);
      indexAttr.setX(faceIndex * 3 + 1, 0);
      indexAttr.setX(faceIndex * 3 + 2, 0);
      geometry.index.needsUpdate = true;
    }

    function undoLastHide() {
      const last = undoStack.pop();
      if (!last) return;
      const { mesh, faceIndex, indices } = last;
      const geometry = mesh.geometry;
      geometry.index.setXYZ(faceIndex, indices[0], indices[1], indices[2]);
      geometry.index.needsUpdate = true;
    }
    let scene, camera, controls, light, renderer;
    async function initThreeJSRenderer() {
      canvas = document.getElementById("threeCanvas");
      const loadedObjects = [];
      let loadedCount = 0;

      lassoCanvas = document.getElementById('lassoCanvas');
      ctx = lassoCanvas.getContext('2d');

      lassoCanvas.width = canvas.clientWidth * window.devicePixelRatio;
      lassoCanvas.height = canvas.clientHeight * window.devicePixelRatio;
      lassoCanvas.style.width = canvas.clientWidth + 'px';
      lassoCanvas.style.height = canvas.clientHeight + 'px';
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.z = 400;
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1A1A1A);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      light = new THREE.DirectionalLight(0xffffff, 0.6);
      light.position.set(0, 1, 1);
      scene.add(light);

      controls = new TrackballControls(camera, renderer.domElement);
      controls.rotateSpeed = 5.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.noZoom = false;
      controls.noPan = false;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;

      canvas.addEventListener('mousemove', onMouseMove);

      document.getElementById('editorBtn').addEventListener('click', () => {
        editMode = !editMode;
        canvas.style.cursor = editMode ? 'crosshair' : 'default';
        controls.enabled = !editMode;
        document.getElementById('editorBtn').textContent = editMode ? '✅ 편집 중 (클릭해서 종료)' : '✂️ ';

        // ✂️ 가위 아이콘 표시/숨김
        scissorIcon.style.display = editMode ? 'block' : 'none';

        // 편집 모드 종료 시 선 및 점 초기화
        if (!editMode) {
          clearLassoPath();
          lassoPoints = [];
        }
      });

      function clearLassoPath() {
        ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
      }

      function isLassoClosed() {
        return true; // 닫히는지 안 닫히는지는 더 이상 검사하지 않음
      }

      canvas.addEventListener('mousedown', (e) => {
        if (!editMode) return; // 편집 모드일 때만 동작

        lassoPoints = [];
        lassoActive = true;
        const rect = lassoCanvas.getBoundingClientRect();
        lassoPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
      });

      const scissorIcon = document.getElementById('scissorIcon');

      canvas.addEventListener('mouseenter', () => {
        if (editMode) {
          scissorIcon.style.display = 'block';
        }
      });

      canvas.addEventListener('mouseleave', () => {
        scissorIcon.style.display = 'none';
      });

      canvas.addEventListener('mousemove', e => {
        if (!editMode) return;

        const rect = canvas.getBoundingClientRect();

        // ✂️ 아이콘 항상 마우스 따라가기
        scissorIcon.style.left = (e.clientX - rect.left + 10) + 'px';
        scissorIcon.style.top = (e.clientY - rect.top + 10) + 'px';

        // lasso 그리기 (lassoActive일 때만)
        if (!lassoActive) return;

        lassoPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
        drawLassoPath();
      });

      canvas.addEventListener('mouseup', () => {
        if (!editMode || lassoPoints.length < 3 || !isLassoClosed()) {
          console.warn("⚠️ 편집 취소: 선이 닫히지 않음");
          clearLassoPath();
          lassoPoints = [];
          return;
        }

        console.log("✅ mouseup: 편집 실행 시작");
        lassoActive = false;

        if (!selectedMesh) {
          alert("편집할 메쉬를 먼저 선택하세요.");
          clearLassoPath();
          lassoPoints = [];
          lassoActive = false;
          return;
        }

        const mesh = selectedMesh;
        const geometry = mesh.geometry;
        if (!geometry || !geometry.attributes?.position || !geometry.index) {
          console.warn("⚠️ geometry 문제", { geometry });
          clearLassoPath();
          lassoPoints = [];
          return;
        }

        const indexArray = geometry.index.array;
        const position = geometry.attributes.position;
        let hideCount = 0;

        for (let i = 0; i < indexArray.length; i += 3) {
          const a = indexArray[i];
          const b = indexArray[i + 1];
          const c = indexArray[i + 2];

          const vA = new THREE.Vector3().fromBufferAttribute(position, a).applyMatrix4(mesh.matrixWorld);
          const vB = new THREE.Vector3().fromBufferAttribute(position, b).applyMatrix4(mesh.matrixWorld);
          const vC = new THREE.Vector3().fromBufferAttribute(position, c).applyMatrix4(mesh.matrixWorld);

          const screenA = toScreen(vA, camera, canvas);
          const screenB = toScreen(vB, camera, canvas);
          const screenC = toScreen(vC, camera, canvas);

          const inLasso = isInsideLasso(screenA) && isInsideLasso(screenB) && isInsideLasso(screenC);
          if (inLasso) {
            hideFace(mesh, i / 3);
            hideCount++;
          }
        }

        console.log(`🔍 ${mesh.userData.label}: 잘린 face 개수:`, hideCount);

        clearLassoPath();
        lassoPoints = [];
      });

      document.getElementById("undoBtn").addEventListener('click', undoLastHide);

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      light.position.copy(camera.position);
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const width = canvas.parentElement.clientWidth;
      const height = canvas.parentElement.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh, idx) => {
        if (!mesh.material) return;
        const row = createMeshRowWithControls(mesh, idx);
        meshListDiv.appendChild(row);
      });
    }

    function createMeshRowWithControls(mesh, idx) {
      const labelText = mesh.userData.label || mesh.name || `Mesh ${idx}`;
      const row = document.createElement('div');

      row.classList.add('mesh-row');
      Object.assign(row.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        background: '#1A1A1A',
        borderRadius: '8px',
        padding: '8px 12px',
        marginBottom: '8px',
        cursor: 'pointer',
      });

      // ✅ 선택된 메쉬일 경우 강조 표시 추가
      if (selectedMesh === mesh) {
        row.classList.add('selected-row');
      }

      row.onclick = () => {
        selectedMesh = mesh;
        undoStack = [];

        // 항상 기존 강조 제거
        document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));

        // 편집 모드일 때만 강조
        if (editMode) {
          row.classList.add('selected-row');
        }
      };

      const left = createLeftLabelSection(mesh, labelText);
      const controlPanel = createVisibilityAndOpacityControl(mesh);

      row.appendChild(left);
      row.appendChild(controlPanel);

      return row;
    }

    function handleMeshSelect(row, mesh, labelText) {
      console.log("✅ 리스트에서 선택된 메쉬:", labelText);
      selectedMesh = mesh;
      undoStack = [];

      // 기존 선택 해제
      document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));
      row.classList.add('selected-row');
    }

    function createLeftLabelSection(mesh, labelText) {
      const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);

      const container = document.createElement('div');
      Object.assign(container.style, {
        display: 'flex',
        alignItems: 'center',
        flex: '1',
      });

      const colorBox = document.createElement('div');
      Object.assign(colorBox.style, {
        width: '12px',
        height: '12px',
        borderRadius: '50%',
        background: `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`,
        marginRight: '8px',
      });

      const label = document.createElement('span');
      label.innerText = labelText;
      Object.assign(label.style, {
        color: '#fff',
        fontSize: '14px',
        flex: '1',
      });

      container.appendChild(colorBox);
      container.appendChild(label);

      return container;
    }

    function createVisibilityAndOpacityControl(mesh) {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.justifyContent = 'space-between';
      container.style.gap = '12px';
      container.style.flex = '1';

      // 왼쪽: 슬라이더 + 숫자
      const sliderGroup = document.createElement('div');
      sliderGroup.style.display = 'flex';
      sliderGroup.style.alignItems = 'center';
      sliderGroup.style.gap = '8px';

      const initialOpacity = mesh.material.opacity ?? 1;
      mesh.material.opacity = initialOpacity;

      const slider = document.createElement('input');
      Object.assign(slider, {
        type: 'range',
        min: 0,
        max: 1,
        step: 0.01,
        value: initialOpacity,
        title: '투명도 조절',
      });
      slider.style.width = '60px';

      const valueText = document.createElement('span');
      valueText.innerText = initialOpacity.toFixed(2);
      valueText.style.fontSize = '12px';
      valueText.style.color = 'white';
      valueText.style.width = '32px';
      valueText.style.textAlign = 'right';

      slider.oninput = (e) => {
        const val = parseFloat(e.target.value);
        mesh.material.opacity = val;
        valueText.innerText = val.toFixed(2);

        if (val < 1.0) {
          Object.assign(mesh.material, {
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.NormalBlending
          });
        } else {
          Object.assign(mesh.material, {
            transparent: false,
            depthWrite: true,
            side: THREE.DoubleSide,
            blending: THREE.NoBlending
          });
        }

        mesh.material.needsUpdate = true;
      };

      sliderGroup.appendChild(slider);
      sliderGroup.appendChild(valueText);

      // 오른쪽: eye 아이콘
      const eye = document.createElement('span');
      eye.style.cursor = 'pointer';
      eye.style.fontSize = '12px';
      eye.style.color = 'white';

      const updateIcon = () => {
        eye.innerHTML = mesh.visible
          ? '<i class="fa-regular fa-eye"></i>'
          : '<i class="fa-regular fa-eye-slash"></i>';
      };

      eye.onclick = (e) => {
        e.stopPropagation();
        mesh.visible = !mesh.visible;
        updateIcon();
        light.position.copy(camera.position);
        renderer.render(scene, camera);
      };

      updateIcon();

      container.appendChild(sliderGroup); // 왼쪽
      container.appendChild(eye);         // 오른쪽

      return container;
    }


    import * as niivue from '../dist/index.js'; // 또는 CDN 사용

    let nvRender; // 전역 선언

    let nvMulti = null;
    const preloadCache = {};


    function renderVolumeTable(volumeRows, containerId = 'volumeTableContent') {
      const container = document.getElementById(containerId);
      container.innerHTML = ''; // 기존 제거

      const totalVolume = volumeRows.reduce((sum, row) => sum + row.volume, 0);

      const table = document.createElement('table');
      table.style.width = '100%';
      table.style.borderCollapse = 'collapse';
      table.style.fontSize = '14px';

      // Header
      const thead = document.createElement('thead');
      thead.style.backgroundColor = '#01506b';
      thead.style.color = 'white';

      const headerRow = document.createElement('tr');

      ['Label', 'Volume (cm³)', '%'].forEach(col => {
        const th = document.createElement('th');
        th.innerText = col;
        th.style.padding = '8px';
        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Body
      const tbody = document.createElement('tbody');
      volumeRows.forEach((row, rowIndex) => {
        const tr = document.createElement('tr');
        tr.style.backgroundColor = rowIndex % 2 === 0 ? '#e1e7ec' : '#f4f6f8';

        const percent = totalVolume > 0 ? (row.volume / totalVolume * 100).toFixed(1) : '-';

        [row.label, row.volume.toFixed(1), percent].forEach((cellData, idx) => {
          const cell = document.createElement('td');
          cell.innerText = cellData;
          cell.style.padding = '8px';
          tr.appendChild(cell);
        });

        tbody.appendChild(tr);
      });

      // Total row 추가
      const trTotal = document.createElement('tr');
      trTotal.style.backgroundColor = '#d1e4f4';
      trTotal.style.fontWeight = 'bold';

      const labelCell = document.createElement('td');
      labelCell.innerText = 'Liver';
      labelCell.style.padding = '8px';

      const volumeCell = document.createElement('td');
      volumeCell.innerText = totalVolume.toFixed(1);
      volumeCell.style.padding = '8px';

      const percentCell = document.createElement('td');
      percentCell.innerText = '100.0';
      percentCell.style.padding = '8px';

      trTotal.appendChild(labelCell);
      trTotal.appendChild(volumeCell);
      trTotal.appendChild(percentCell);

      tbody.appendChild(trTotal);

      table.appendChild(tbody);
      container.appendChild(table);
    }


    async function isSegmentationNRRD(urlSeg) {
      const text = await fetch(urlSeg).then(r => r.text());
      // Segment_Color 만 있어도 segmentation으로 처리 (테스트용)
      return /Segment\d+_(LabelValue|Color)/i.test(text);
    }


    async function initNiivueMultiViewer(niiUrl, nrrdUrl, labelColorMap) {
      const isSegmentation = await isSegmentationNRRD(nrrdUrl);
      console.log("isSegmentationNRRD =", isSegmentation);

      let volumeList;

      const nvMulti = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.MULTIPLANE,
        dragAndDropEnabled: false,
        isOrientCube: true,
        backColor: [0, 0, 0, 1],
        logLevel: "none"
      });

      await nvMulti.attachTo("canvasMulti");

      if (isSegmentation) {
        // 여기에서 서버에서 받은 labelColorMap 사용
        const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap);
        niivue.cmapper.addColormap('seg', segCmap);

        const labelLUT = niivue.cmapper.makeLabelLut(segCmap, Math.max(...segCmap.I));

        volumeList = [
          { url: niiUrl, colormap: 'gray', opacity: 1 },
          { url: nrrdUrl, colormap: 'seg', cal_min: labelLUT.min, cal_max: labelLUT.max }
        ];

        await nvMulti.loadVolumes(volumeList);

        flipVolumeX(nvMulti.volumes[0]);
        flipVolumeX(nvMulti.volumes[1]);

        nvMulti.volumes[1].lut = labelLUT.lut;
        nvMulti.volumes[1].cal_min = labelLUT.min;
        nvMulti.volumes[1].cal_max = labelLUT.max;

      } else {
        volumeList = [
          { url: niiUrl, colormap: 'gray', opacity: 1 },
          { url: nrrdUrl, colormap: 'gray', opacity: 0.5 }
        ];

        await nvMulti.loadVolumes(volumeList);

        flipVolumeX(nvMulti.volumes[0]);
        flipVolumeX(nvMulti.volumes[1]);
      }

      nvMulti.updateGLVolume();
      nvMulti.drawScene();
    }

    async function initNiivueViewers() {
      nvRender = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.RENDER,
        dragAndDropEnabled: false,
        isOrientCube: true,
        show3Dcrosshair: false,
        backColor: [0.5, 0.5, 1, 1],
        gradientOpacity: 0.3,
        logLevel: "none"
      });

      await nvRender.attachTo("canvasRender");
      nvRender.setSliceType(nvRender.sliceTypeRender);
    }

    const convertBtn = document.getElementById("convertBtn");
    const nrrdInput = document.getElementById("nrrdInput");
    let colorMap = {};


    function applyMeshColors(meshes, colorMap) {
      const INITIAL_OPACITY = 0.1;

      meshes.forEach(mesh => {
        mesh.material.transparent = true;
        mesh.material.opacity = INITIAL_OPACITY;

        const matName = mesh.material.name.trim();
        const labelValue = window.labelNameToLabelValueMap?.[matName];
        let fallbackColor;

        if (labelValue !== undefined) {
          // LabelValue → LUT 에서 색 가져오기
          const lutIndex = Math.floor(labelValue);
          fallbackColor = [
            niivue.cmapper._colormaps['seg'].R[lutIndex],
            niivue.cmapper._colormaps['seg'].G[lutIndex],
            niivue.cmapper._colormaps['seg'].B[lutIndex],
            255
          ];
        } else {
          // fallback: MTL 기반 colorMap 사용
          fallbackColor = colorMap[matName] || [255, 0, 0, 255];
        }

        console.log(`[applyMeshColors] ${matName} →`, fallbackColor);

        mesh.material.color = new THREE.Color(
          fallbackColor[0] / 255,
          fallbackColor[1] / 255,
          fallbackColor[2] / 255
        );

        mesh.material.needsUpdate = true;

        mesh.rgba255 = fallbackColor;
        mesh.color = fallbackColor.slice(0, 3).map(x => x / 255);
      });
    }
    // function applyMeshColors(meshes, colorMap, nvRender) {
    //   meshes.forEach(mesh => {
    //     // 필요에 따라 prefix 처리 등 조정
    //     const matName = mesh.name.replace('.obj', '');

    //     if (colorMap[matName]) {
    //       const rgba = colorMap[matName];
    //       mesh.rgba255 = rgba.slice();
    //       mesh.color = rgba.slice(0, 3).map(x => x / 255);
    //       mesh.updateMesh(nvRender.gl);
    //     } else {
    //       // 진단용: 매칭 안되면 빨간색
    //       mesh.rgba255 = [255, 0, 0, 255];
    //       mesh.color = [1, 0, 0];
    //       mesh.updateMesh(nvRender.gl);
    //     }
    //   });
    //   nvRender.drawScene();
    // }

    // 3. 메쉬 리스트 UI 렌더링
    function renderMeshListUI() {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = ''; // 초기화

      nvRender.meshes.forEach((mesh, idx) => {
        const matName = mesh.name.replace('.obj', '');
        const rgba = colorMap[matName] || [128, 128, 128, 255];
        const labelText = matName.replace(/^segment_/, '');

        // 컨테이너
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.marginBottom = '8px';

        row.onclick = () => {
          // 기존 선택 해제
          document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));

          // 선택 표시
          row.classList.add('selected-row');

          // 해당 메쉬를 선택
          selectedMesh = mesh;

          // 선택되었음을 log로 확인
          console.log("✅ 리스트에서 선택된 메쉬:", mesh.name);

          // UndoStack 초기화
          undoStack = [];
        };

        // 눈 아이콘
        const eye = document.createElement('span');
        eye.innerHTML = mesh.visible ? '👁️' : '🙈';
        eye.style.cursor = 'pointer';
        eye.style.fontSize = '20px';
        eye.onclick = () => {
          mesh.visible = !mesh.visible;
          // Niivue는 mesh.visible = false면 해당 mesh가 아예 안 나옴
          nvRender.updateGLVolume();
          nvRender.drawScene();
          renderMeshListUI(); // 상태(눈 아이콘) 갱신
        };

        // 색상 박스
        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '32px';
        colorBox.style.height = '32px';
        colorBox.style.marginLeft = '10px';
        colorBox.style.marginRight = '10px';
        colorBox.style.background = `rgba(${rgba[0]},${rgba[1]},${rgba[2]},1)`;
        colorBox.style.borderRadius = '3px';
        colorBox.style.border = '1px solid #aaa';

        // 라벨 + opacity 슬라이더 컨테이너
        const labelContainer = document.createElement('div');
        labelContainer.style.display = 'flex';
        labelContainer.style.flexDirection = 'column';

        // 라벨
        const label = document.createElement('span');
        label.innerText = labelText;
        label.style.fontSize = '20px';

        // Opacity 슬라이더
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0;
        slider.max = 1;
        slider.step = 0.01;
        // mesh.opacity 값이 undefined면 1로 초기화
        if (typeof mesh.opacity !== 'number') mesh.opacity = 1;
        slider.value = mesh.opacity;

        slider.style.width = '60px';
        slider.title = '투명도';

        // 현재 opacity 값
        const sliderValue = document.createElement('span');
        sliderValue.innerText = mesh.opacity.toFixed(2);
        sliderValue.style.fontSize = '12px';
        sliderValue.style.marginLeft = '8px';

        slider.oninput = (e) => {
          const val = parseFloat(e.target.value);
          mesh.opacity = val;
          if (mesh.rgba255) mesh.rgba255[3] = Math.round(255 * val);
          mesh.updateMesh(nvRender.gl);
          nvRender.drawScene();
          sliderValue.innerText = val.toFixed(2);
          console.log(`[slider] ${mesh.name} ${val}`, mesh.rgba255);
        };

        // 조립
        labelContainer.appendChild(label);
        // 라벨 아래에 슬라이더 + 값 표시
        const sliderRow = document.createElement('div');
        sliderRow.style.display = 'flex';
        sliderRow.style.alignItems = 'center';
        sliderRow.appendChild(slider);
        sliderRow.appendChild(sliderValue);
        labelContainer.appendChild(sliderRow);

        row.appendChild(eye);
        row.appendChild(colorBox);
        row.appendChild(labelContainer);

        meshListDiv.appendChild(row);
      });
    }

    // mtlText에서 newmtl ~ Kd 색상을 추출해서 colorMap 만들기
    function parseMtlColors(mtlText) {
      const colorMap = {};
      let currentMat = null;
      mtlText.split('\n').forEach(line => {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMat = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMat) {
          const [r, g, b] = line.split(' ').slice(1).map(x => Math.round(parseFloat(x) * 255));
          colorMap[currentMat] = [r, g, b, 255];
        }
      });

      return colorMap;
    }

    // .mtl 파일 파싱 함수
    async function parseMtlFile(mtlUrl) {
      const res = await fetch(mtlUrl);
      if (!res.ok) throw new Error("MTL 파일 로드 실패");
      const text = await res.text();
      const lines = text.split('\n');
      const colorMap = {};
      let currentMaterial = null;
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          currentMaterial = line.split(' ')[1];
        } else if (line.startsWith('Kd ') && currentMaterial) {
          const [r, g, b] = line.split(' ').slice(1).map(Number);
          colorMap[currentMaterial] = [r * 255, g * 255, b * 255, 255];
          // console.log(`[MTL파싱] ${currentMaterial} →`, colorMap[currentMaterial]);
        }
      }
      return colorMap;
    }

    // const toggleBtn = document.getElementById('toggleOrientation')
    // toggleBtn.addEventListener('click', () => {
    //   orientationVisible = !orientationVisible
    //   nv1.setIsOrientationTextVisible(orientationVisible)
    //   toggleBtn.textContent = orientationVisible ? 'Hide Orientation Text' : 'Show Orientation Text'
    // })


    // import * as niivue from '../dist/index.js';


    const status = document.getElementById('status');
    const folderInput = document.getElementById('folderInput');

    // const urlCT = '../images/CTLiver.nii.gz';
    // const urlCT = await preloadVolume('../images/CTLiver.nii.gz');
    // const urlSeg = '../images/CTLiverSegmentation.nrrd';
    // console.log("Preloaded:", { urlCT, urlSeg });
    // await loadAndVisualize(urlCT, urlSeg);

    folderInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files).filter(f => f.name.endsWith('.dcm'));
      if (!files.length) {
        status.textContent = "DICOM(.dcm) 파일이 없습니다.";
        return;
      }

      const fullPath = files[0].webkitRelativePath || '';
      // const folderName = Date.now().toString();
      const folderName = document.getElementById('folderInput').files[0].webkitRelativePath.split('/')[0];
      status.textContent = `'${folderName}' 업로드 중...`;

      const formData = new FormData();
      files.forEach(f => formData.append('dicomFiles', f));
      formData.append('folder', folderName);

      try {
        const res = await fetch('http://127.0.0.1:5000/upload-and-infer-all', {
          method: 'POST',
          body: formData
        });
        const json = await res.json();
        console.log("json:", json);
        if (!json.success) throw new Error(json.message);

        status.textContent = "시각화 준비 중...";

        const urlCT = "http://127.0.0.1:5000" + json.niiUrl;
        const urlSeg = "http://127.0.0.1:5000" + json.nrrdUrl;
        const labelColorMap = json.labelColorMap;
        await initNiivueMultiViewer(urlCT, urlSeg, labelColorMap);

        const meshList = json.objUrls.map(url => ({
          url: "http://127.0.0.1:5000" + url,
          visible: true
        }));

        const mtlUrl = "http://127.0.0.1:5000" + json.mtlUrl;
        await loadMeshesIntoThreeJS(meshList, mtlUrl, () => {
          const volumeRows = threeMeshes.map(mesh => {
            const volume = computeMeshVolume(mesh);
            return {
              label: mesh.userData.label || mesh.name,
              volume: volume
            };
          });

          renderVolumeTable(volumeRows);
        });
        // await loadAndVisualize(json.niiUrl, json.nrrdUrl);

        // const urlCT = '../images/CTLiver.nii.gz';
        // const urlSeg = '../images/CTLiverSegmentation.nrrd';
        // await loadAndVisualize(urlCT, urlSeg);

        status.textContent = "완료되었습니다.";
      } catch (err) {
        console.error(err);
        status.textContent = "❌ 오류: " + err.message;
      }
    });

    function computeMeshVolume(mesh) {
      const geometry = mesh.geometry;
      if (!geometry.isBufferGeometry) return 0;

      const posAttr = geometry.attributes.position;
      const indexAttr = geometry.index;

      let volume = 0.0;

      for (let i = 0; i < indexAttr.count; i += 3) {
        const a = indexAttr.getX(i);
        const b = indexAttr.getX(i + 1);
        const c = indexAttr.getX(i + 2);

        const p1 = new THREE.Vector3().fromBufferAttribute(posAttr, a);
        const p2 = new THREE.Vector3().fromBufferAttribute(posAttr, b);
        const p3 = new THREE.Vector3().fromBufferAttribute(posAttr, c);

        volume += signedVolumeOfTriangle(p1, p2, p3);
      }

      return Math.abs(volume);
    }


    function signedVolumeOfTriangle(p1, p2, p3) {
      return p1.dot(p2.cross(p3)) / 6.0;
    }

    function updateMeshLabels() {
      const labelContainer = document.getElementById('labelContainer');
      labelContainer.innerHTML = '';  // 기존 label 초기화

      threeMeshes.forEach(mesh => {
        if (!mesh.visible) return;

        const pos = new THREE.Vector3();
        mesh.geometry.computeBoundingBox();
        mesh.geometry.boundingBox.getCenter(pos);
        pos.applyMatrix4(mesh.matrixWorld);

        const vector = pos.clone().project(camera);
        const rect = renderer.domElement.getBoundingClientRect();
        const x = (vector.x + 1) / 2 * rect.width;
        const y = (-vector.y + 1) / 2 * rect.height;

        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.transform = `translate(-50%, -50%)`;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.padding = '2px 6px';
        div.style.background = 'rgba(0,0,0,0.7)';
        div.style.color = '#fff';
        div.style.borderRadius = '4px';
        div.style.fontSize = '12px';
        div.style.fontWeight = 'bold';
        div.style.border = `2px solid #${Math.floor(mesh.material.color.getHex()).toString(16).padStart(6, '0')}`;
        div.innerText = mesh.userData.label || mesh.name;

        labelContainer.appendChild(div);
      });
    }

    async function loadMeshesIntoThreeJS(meshList, mtlUrl, onComplete) {
      // 기존 메쉬 삭제
      threeMeshes.forEach(mesh => {
        scene.remove(mesh.parent);  // parent (Object3D) 통째로 삭제
      });

      threeMeshes.length = 0;
      colorMap = await parseMtlFile(mtlUrl);
      console.log("✅ colorMap loaded", colorMap);

      const mtlPath = mtlUrl.substring(0, mtlUrl.lastIndexOf("/") + 1);
      const mtlLoader = new MTLLoader();
      mtlLoader.setResourcePath(mtlPath);
      mtlLoader.setPath(mtlPath);

      mtlLoader.load("segments.mtl", materials => {
        materials.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath(mtlPath);

        const loadedObjects = [];
        let loadedCount = 0;

        meshList.forEach(mesh => {
          const filename = mesh.url.split("/").pop();

          objLoader.load(filename, object => {
            object.traverse(child => {
              if (child instanceof THREE.Mesh) {
                child.geometry = BufferGeometryUtils.mergeVertices(child.geometry);
                child.geometry.computeVertexNormals();

                const matName = child.material.name.trim();
                const fallbackColor = colorMap[matName] || [128, 128, 128, 255];
                const color = new THREE.Color(
                  fallbackColor[0] / 255,
                  fallbackColor[1] / 255,
                  fallbackColor[2] / 255
                );

                child.material = new THREE.MeshPhongMaterial({
                  color: color,
                  shininess: 40,
                  specular: new THREE.Color(0.5, 0.5, 0.5),
                  side: THREE.DoubleSide,
                  transparent: true,
                  opacity: 1.0,
                  depthWrite: true,
                  blending: THREE.NormalBlending
                });

                child.userData.label = filename.replace('.obj', '').replace('segment_', '');
                threeMeshes.push(child);
              }
            });

            loadedObjects.push(object);
            scene.add(object);  // 기존 삭제 후 새로운 object만 추가
            loadedCount++;

            if (loadedCount === meshList.length) {
              const fullBox = new THREE.Box3();
              loadedObjects.forEach(obj => fullBox.expandByObject(obj));
              const center = new THREE.Vector3();
              fullBox.getCenter(center);

              loadedObjects.forEach(obj => obj.position.sub(center));

              camera.up.set(0, 1, 0);

              const size = new THREE.Vector3();
              fullBox.getSize(size);

              const maxSize = Math.max(size.x, size.y, size.z);
              const fov = camera.fov * (Math.PI / 180);
              const distance = maxSize / (2 * Math.tan(fov / 2));

              const paddingFactor = 1.2;
              camera.position.set(distance * -1.2, distance * 0.4, distance * 1.2);
              camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 12);

              camera.lookAt(0, 0, 0);
              controls.target.set(0, 0, 0);
              controls.update();

              animate();
              renderThreeMeshListUI(threeMeshes);

              if (onComplete) onComplete();
            }
          });
        });
      });
    }

    async function preloadVolume(url) {
      if (preloadCache[url]) return preloadCache[url];
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Fetch failed: ${url}`);
      const blob = await response.blob();
      const objectURL = URL.createObjectURL(blob);
      preloadCache[url] = objectURL;
      return objectURL;
    }

    async function loadAndVisualize(urlCT, urlSeg) {
      const { segCmap, labelLUT } = await loadColormapAndLUT(urlSeg);

      const volumeList = [
        { url: urlCT, colormap: 'gray', opacity: 1 },
        {
          url: urlSeg,
          colormap: 'seg',
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 1
        }
      ];

      // ✅ [2단계] 하나의 뷰어만 loadVolumes 실행
      const nvAxial = await setupViewer('canvasAxial', niivue.SLICE_TYPE.AXIAL);
      const nvCoronal = await setupViewer('canvasCoronal', niivue.SLICE_TYPE.CORONAL);
      const nvSagittal = await setupViewer('canvasSagittal', niivue.SLICE_TYPE.SAGITTAL);
      const nvRender = await setupViewer('canvasRender', niivue.SLICE_TYPE.RENDER);

      console.time("loadVolumes");
      await nvAxial.loadVolumes(volumeList);
      console.timeEnd("loadVolumes");
      // ✅ [3단계] 나머지 뷰어는 loadVolumes 없이 volumeList를 직접 설정
      await nvCoronal.loadVolumes(volumeList);
      await nvSagittal.loadVolumes(volumeList);
      await nvRender.loadVolumes([volumeList[1]]);

      // ✅ [4단계] LUT 및 flip 적용 (각각의 volume 객체에 대해)
      for (const nv of [nvAxial, nvCoronal, nvSagittal]) {
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        nv.updateGLVolume();
        // nv.drawScene();
      }

      nvRender.volumes[0].lut = labelLUT.lut;
      nvRender.volumes[0].cal_min = labelLUT.min;
      nvRender.volumes[0].cal_max = labelLUT.max;
      nvRender.updateGLVolume();
      nvRender.drawScene();

      // ✅ [5단계] 위치 동기화
      for (let nv of [nvAxial, nvCoronal, nvSagittal]) {
        nv.broadcastTo([nvAxial, nvCoronal, nvSagittal, nvRender]);
      }
      // nvAxial.broadcastTo([nvCoronal, nvSagittal, nvRender]); // 하나만 마스터로

      // ✅ [6단계] 컨트롤러 바인딩
      bindRenderControls(nvRender);
    }
    function parseNrrdColorMapAndNameMap(nrrdHeader) {
      const colorMap = {};
      const labelValueToNameMap = {};
      const labelNameToLabelValueMap = {};

      for (const key in nrrdHeader) {
        if (key.match(/Segment\d+_Color/i)) {
          const segmentId = key.match(/Segment(\d+)_Color/i)[1];
          const segmentKey = `segment${segmentId}`;
          const colorValues = nrrdHeader[key].split(' ').map(Number);
          colorMap[segmentKey] = [
            Math.round(colorValues[0] * 255),
            Math.round(colorValues[1] * 255),
            Math.round(colorValues[2] * 255),
            255
          ];
        }
        if (key.match(/Segment\d+_LabelValue/i)) {
          const segmentId = key.match(/Segment(\d+)_LabelValue/i)[1];
          const value = parseInt(nrrdHeader[key]);
          labelValueToNameMap[value] = `segment${segmentId}`; // 기본값
        }
        if (key.match(/Segment\d+_LabelName/i)) {
          const segmentId = key.match(/Segment(\d+)_LabelName/i)[1];
          const labelValueKey = `Segment${segmentId}_LabelValue`;
          const value = parseInt(nrrdHeader[labelValueKey]);
          const labelName = nrrdHeader[key].trim();

          labelValueToNameMap[value] = labelName;
          labelNameToLabelValueMap[labelName] = value;
        }
      }

      return { colorMap, labelValueToNameMap, labelNameToLabelValueMap };
    }

    function makeNiivueColormapFromLabelColorMap(labelColorMap) {
      const I = [], R = [], G = [], B = [], A = [];

      for (let i = 0; i <= 255; i++) {
        const labelName = window.labelValueToNameMap?.[i] ?? null;
        const segmentName = labelName ? `segment_${labelName}` : null;

        if (segmentName && labelColorMap[segmentName]) {
          const [r, g, b, a] = labelColorMap[segmentName];
          R.push(r);
          G.push(g);
          B.push(b);
          A.push(a);
        } else {
          R.push(0);
          G.push(0);
          B.push(0);
          A.push(0);
        }

        I.push(i);
      }

      return { I, R, G, B, A };
    }

    async function loadColormapAndLUT(urlSeg) {
      // 1️⃣ NRRD 헤더 파싱
      const nrrdResponse = await fetch(urlSeg);
      const nrrdText = await nrrdResponse.text();
      const nrrdHeader = parseNrrdHeader(nrrdText);

      // 2️⃣ ColorMap / LabelNameMap 파싱
      const raw = parseNrrdColorMap(nrrdHeader);
      const { colorMap: nrrdColorMap, labelValueToNameMap, labelNameToLabelValueMap } = parseNrrdColorMapAndNameMap(nrrdHeader);

      // 3️⃣ Niivue용 colormap 생성
      const segCmap = makeNiivueColormap(nrrdHeader);
      niivue.cmapper.addColormap('seg', segCmap);

      // 4️⃣ LUT 생성
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, Math.max(...segCmap.I));

      // 5️⃣ 전역 변수 등록
      window.labelValueToNameMap = labelValueToNameMap;
      window.labelNameToLabelValueMap = labelNameToLabelValueMap;

      // 6️⃣ Three.js용 colorMap 구성
      colorMap = {};
      for (const key in labelValueToNameMap) {
        const labelName = labelValueToNameMap[key];
        const fallbackColor = nrrdColorMap[`segment${key}`] || nrrdColorMap[labelName] || [128, 128, 128, 255];
        colorMap[labelName] = fallbackColor;
      }

      console.log('✅ labelValueToNameMap:', labelValueToNameMap);
      console.log('✅ labelNameToLabelValueMap:', labelNameToLabelValueMap);
      console.log('✅ Three.js colorMap:', colorMap);

      return { segCmap, labelLUT };
    }

    function makeNiivueColormap(nrrdHeader) {
      const raw = parseNrrdColorMap(nrrdHeader);
      const I = [], R = [], G = [], B = [], A = [];
      for (let i = 0; i <= 255; i++) {
        if (raw[`segment${i}`]) {
          const rgba = raw[`segment${i}`];
          R.push(rgba[0]);
          G.push(rgba[1]);
          B.push(rgba[2]);
          A.push(rgba[3]);
          I.push(i);
        } else {
          R.push(0); G.push(0); B.push(0); A.push(0); I.push(i);
        }
      }
      return { I, R, G, B, A };
    }

    function parseNrrdColorMap(nrrdHeader) {
      const colorMap = {};
      for (const key in nrrdHeader) {
        if (key.match(/Segment\d+_Color/i)) {
          const segmentId = key.match(/Segment(\d+)_Color/i)[1];
          const segmentKey = `segment${segmentId}`; // 반드시 segment1, segment2 등으로 고정
          const colorValues = nrrdHeader[key].split(' ').map(Number);
          colorMap[segmentKey] = [
            Math.round(colorValues[0] * 255),
            Math.round(colorValues[1] * 255),
            Math.round(colorValues[2] * 255),
            255
          ];
        }
      }
      return colorMap;
    }

    function parseNrrdHeader(nrrdText) {
      const header = {};
      const lines = nrrdText.split('\n');
      for (let line of lines) {
        line = line.trim();
        if (line === '' || line.startsWith('#')) continue;
        const parts = line.split(':');
        if (parts.length < 2) continue;
        const key = parts[0].trim();
        const value = parts.slice(1).join(':').trim();
        header[key] = value;
      }
      return header;
    }

    async function initViewers(viewConfigs) {
      const viewers = {};
      for (const { id, type } of viewConfigs) {
        viewers[id] = await setupViewer(id, type);
      }
      return viewers;
    }

    async function setupViewer(canvasId, sliceType) {
      const defaults = {
        backColor: [0, 0, 0, 1],
        show3Dcrosshair: true,
        logLevel: 'none',
        dragAndDropEnabled: false
      };
      if (sliceType === niivue.SLICE_TYPE.RENDER) {
        defaults.gradientOpacity = 0.3;
        defaults.backColor = [0.5, 0.5, 1, 1];
      }
      const nv = new niivue.Niivue(defaults);
      await nv.attachTo(canvasId);
      nv.setSliceType(sliceType);
      nv.opts.isOrientCube = true;
      return nv;
    }

    async function loadVolumesToSliceViews(viewers, volumeList, labelLUT) {
      for (let nv of viewers) {
        await nv.loadVolumes(volumeList);
        flipVolumeX(nv.volumes[0]);
        flipVolumeX(nv.volumes[1]);
        nv.volumes[1].lut = labelLUT.lut;
        nv.volumes[1].cal_min = labelLUT.min;
        nv.volumes[1].cal_max = labelLUT.max;
        // nv.updateGLVolume();
        nv.drawScene();
      }
    }

    function flipVolumeX(volume) {
      const dims = volume.dimsRAS;
      const xSize = dims[1], ySize = dims[2], zSize = dims[3];
      const flipped = new volume.img.constructor(volume.img.length);

      const sliceSize = xSize * ySize;
      for (let z = 0; z < zSize; z++) {
        const offsetZ = z * sliceSize;
        for (let y = 0; y < ySize; y++) {
          const rowOffset = offsetZ + y * xSize;
          for (let x = 0; x < xSize; x++) {
            const src = rowOffset + x;
            const dst = rowOffset + (xSize - 1 - x);
            flipped[dst] = volume.img[src];
          }
        }
      }
      volume.img = flipped;
    }

    async function loadVolumesToRenderView(nv, urlSeg, labelLUT) {
      await nv.loadVolumes([{
        url: urlSeg,
        colormap: 'seg',
        cal_min: labelLUT.min,
        cal_max: labelLUT.max,
        opacity: 1
      }]);
    }

    function bindRenderControls(nvRender) {
      // gradientOpacity.oninput = function () {
      //   nvRender.setGradientOpacity(this.value * 0.1);
      // };
      // illumination.oninput = function () {
      //   nvRender.setVolumeRenderIllumination(this.value * 0.1);
      // };
      // gradientOrder.onchange = function () {
      //   nvRender.opts.gradientOrder = parseInt(this.value);
      //   nvRender.updateGLVolume();
      // };
    }
  </script>

  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
      background: black;
    }

    header {
      width: 100vw;
      height: 56px;
      /* 필요에 따라 40~80px */
      min-height: 40px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #meshSidebar {
      pointer-events: auto;
      z-index: 10;
      flex: 0 1 270px;
      /* shrink, grow 허용 */
      min-width: 150px;
      /* 최소 너비 (원하는 값) */
      border-right: 1px solid #ddd;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
    }

    #topHalf,
    #bottomHalf {
      width: 100%;
      height: 50%;
    }

    #threeCanvas {
      pointer-events: auto;
      /* 또는 all */
      z-index: 1;
      /* sidebar보다 낮아야 클릭 통과 */
      width: 100%;
      height: 100%;
      display: block;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 10px;
      box-shadow: 0 0 4px rgba(0, 123, 255, 0.3);
    }

    #mainLayout {
      display: flex;
      flex-direction: row;
      /* 명시적으로 좌-중-우 배치 */
      width: 100vw;
      height: calc(100vh - 56px);
      overflow: hidden;
    }

    #viewerArea {
      flex: 1 1 auto;
      /* 남는 공간 다 사용 */
      min-width: 0;
      /* overflow 방지 */
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #volumeTableArea {
      width: 300px;
      /* background: #fff; */
      padding: 16px;
      border-left: 1px solid #ccc;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
    }

    header button,
    header input[type="file"] {
      font-size: 14px;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      margin-right: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    header button:hover,
    header input[type="file"]:hover {
      background-color: #0056b3;
    }

    header button:active,
    header input[type="file"]:active {
      background-color: #004999;
    }

    header #status {
      font-size: 14px;
      color: white;
      margin-left: 12px;
    }

    #volumeTableContent table {
      width: 100%;
      border-collapse: collapse;
      font-size: 15px;
      border: 1px solid #ccc;
    }

    #volumeTableContent thead {
      background-color: #004c7f;
      /* 좀 더 깊은 블루 */
      color: white;
    }

    #volumeTableContent thead th {
      padding: 10px;
      border-bottom: 1px solid #ccc;
      text-align: left;
    }

    #volumeTableContent tbody tr:nth-child(even) {
      background-color: #f2f6f9;
    }

    #volumeTableContent tbody tr:nth-child(odd) {
      background-color: #e8eff5;
    }

    #volumeTableContent tbody td {
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    #volumeTableContent tbody tr:last-child {
      background-color: #e0f0ff;
      /* Total 행 배경 */
      font-weight: bold;
    }

    #volumeTableContent tbody tr:last-child td {
      color: #003366;
    }
  </style>
</body>

</html>