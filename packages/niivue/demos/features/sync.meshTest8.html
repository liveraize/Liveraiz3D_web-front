<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 56px;
  padding: 0 20px;
  background-color: #111;
  border-bottom: 1px solid #444;
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-sizing: border-box;
">
    <!-- ì¢Œì¸¡ -->
    <!-- ê°€ìš´ë° (ë¡œê³  + í…ìŠ¤íŠ¸) -->
    <!-- âœ… ë¡œê³  ì˜ì—­ -->
    <div style="display: flex; align-items: center;">
      <img src="../images/logo.png" alt="Liveraizer Logo" style="
      height: 36px;
      object-fit: contain;
      display: block;
    ">
    </div>

    <!-- ìš°ì¸¡ (ë²„íŠ¼) -->
    <div style="display: flex; align-items: center;">
      <button id="undoBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">â†©ï¸</button>

      <button id="editorBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">âœ‚ï¸</button>

      <button id="editModeBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #0066cc;   /* íŒŒë€ìƒ‰ ë°°ê²½ */
      color: white;
      cursor: pointer;
      margin-left: 4px;
    ">ğŸ¯ ë¶€ë¶„</button>


    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="file" id="folderInput" webkitdirectory multiple style="
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      font-size: 14px;
    " />
      <span id="status" style="font-size: 14px; color: #ccc;">ì§„í–‰ ì¤‘ ì—†ìŒ</span>
    </div>
    <input type="file" id="dicomInput" webkitdirectory multiple />
    <!-- <p id="status">ìƒíƒœ ë©”ì‹œì§€</p> -->
  </header>
  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
    </div>

    <div id="viewerArea">
      <div id="viewerContentArea" style="flex:1; display:flex; flex-direction:column;">
        <!-- Top Mesh Area-->
        
        <div class="viewport-top">
          <div id="leftTopContainer">
            <canvas id="leftTop"></canvas>
          </div>
          
          <div id="bottomHalf" style="position: relative;">
            <div id="labelContainer" style="position:absolute; top:0; left:0; pointer-events:none; z-index:20;"></div>
            <canvas id="threeCanvas"></canvas>
            <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
            <div id="scissorIcon" style="
              position: absolute;
              z-index: 100;
              pointer-events: none;
              display: none;
              font-size: 20px;
            ">âœ‚ï¸</div>
          </div>
        </div>
        <!-- Third 2D Image Area-->
        <div id="topViewer" style="height: 300px;">
          <canvas id="canvasTop" style="width:100%; height:100%;"></canvas>
          <canvas id="canvasMulti" style="width:100%; height:100%"></canvas>
        </div>
      </div>
    </div>

    <div id="volumeTableArea">
      <div id="volumeTableContent"></div>
    </div>
  </div>
  <style>
    .viewport-top {
      height: 50%;
      width: 100%;

      background-color: #fff;

      display: flex;
      flex-direction: row;
    }

    #leftTopContainer {
      width: 50%;
      height: 100%;
    }

    #leftTop {
      width: 100%;
      height: 100%;
      display: block;
      background-color: gray;
      border-color: red;
      border-style: solid;
    }

    #topViewer {
      height: 50%;
    }

    #lassoCanvas {
      width: 100%;
      height: 100%;
      z-index: 10;
    }

  </style>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>
  <script type="module">
    import JSZip from 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm';

    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { NRRDLoader } from 'three/examples/jsm/loaders/NRRDLoader.js';

    import { OBJExporter } from "three/examples/jsm/exporters/OBJExporter.js";

    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js';

    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';

    import { renderNrrdMesh,  } from './viewer/renderNrrdMesh.js';
    import {
      labelColorMap, labelNameMap,
      applyColorTheme, createNiivueLUT, applyMeshColors
    } from './viewer/colorMaps.js';

    import { marchingCubes } from './utils/marchingCubes.js';
    import { uploadAndInferDicomBundle } from './upload/uploadAndInferDicomBundle.js';

    import * as niivue from '../dist/index.js'; // ë˜ëŠ” CDN ì‚¬ìš©

    import { LassoEditor } from './editor/lassoEditor.js';
    import { meshToVoxel } from './utils/meshToVolume.js';
    import { voxelToNRRD } from './utils/nrrdEncoder.js';

    
    const originalWarn = console.warn;

    console.warn = (...args) => {
      if (args[0] && args[0].includes("niivue-warn")) {
        return; // Niivue ê´€ë ¨ ê²½ê³ ëŠ” ë¬´ì‹œ
      }
      originalWarn(...args); // ë‹¤ë¥¸ ê²½ê³ ëŠ” ê·¸ëŒ€ë¡œ ì¶œë ¥
    };
    // import * as niivue from "https://unpkg.com/@niivue/niivue@latest/dist/index.js";
    // import * as niivue from "https://unpkg.com/@niivue/niivue@0.58.5/dist/index.js";
    let threeMeshes = [];
    let meshMap = {};
    let hiddenFaces = new Map();
    let undoStack = [];
    let selectedMesh = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMesh = null;

    const canvas = document.getElementById('threeCanvas');
    let scene, camera, renderer;

    let controls = null;
    let nvMulti = null;     // ë©€í‹°í”Œë ˆì¸ ë·°ì–´
    let nvRender = null;    // ë Œë” ë·°ì–´
    let niiUrl = null;

    const label_name_mapping = {
      1: "Liver",
      2: "Rt.lobe",
      3: "RAS",
      4: "RPS",
      5: "Lt.lobe",
      6: "LLS",
      7: "LMS",
      8: "Spigelian",
      9: "PV",
      10: "HV",
      11: "Cancer",
      12: "BD"
    }

    var boundingBoxHelper = undefined;

    const labelColorMap1 = {
      1: [238, 112, 70, 255],   // Liver - ë¶‰ì€ ì£¼í™©
      2: [238, 112, 70, 255],   // Rt.lobe
      3: [218, 108, 110, 255],  // RAS - ì—°ë¶‰ì€ìƒ‰
      4: [138, 117, 231, 255],  // RPS - ë³´ë¼
      5: [211, 255, 51, 255],   // Lt.lobe - ë…¸ë‘
      6: [255, 50, 50, 255],   // âœ… LLS - ê°•í•œ ì£¼í™© (ê¸°ì¡´ë³´ë‹¤ ë¶‰ì€ í†¤)
      7: [40, 255, 120, 255],    // âœ… LMS - ì§„í•œ ì—°ë‘ â†’ ì±„ë„ ê°•í™”
      8: [50, 230, 120, 255],   // âœ… Spigelian - ë¯¼íŠ¸ë³´ë‹¤ ì§„í•œ ì´ˆë¡
      9: [193, 157, 255, 255],  // PV - ì—°ë³´ë¼
      10: [139, 186, 255, 255], // HV - í•˜ëŠ˜ìƒ‰
      11: [234, 36, 36, 255],   // Cancer - ê°•ë ¬í•œ ë¹¨ê°•
      12: [50, 230, 120, 255],    // âœ… BD - ê°•í•œ ë…¹ìƒ‰ (ê°ˆìƒ‰ ëŠë‚Œ ì œê±°)
      // 255: [255, 255, 255, 255]  // í¸ì§‘ëœ ë¶€ë¶„ - í•˜ì–€ìƒ‰
      255: [1.0, 1.0, 1.0, 0.0]   // í¸ì§‘ëœ ë¶€ë¶„ - íˆ¬ëª…
    };

    initThreeJS()
    loadTestVolumes();

    function initThreeJS() {
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

      const ro = new ResizeObserver(() => {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(w, h, false);

        camera.aspect = w / h;        // Perspective
        camera.updateProjectionMatrix();
      });
      ro.observe(canvas);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 5000);
      camera.position.set(500, 500, 500);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // âœ… AmbientLight: ì „ì²´ì ì¸ ê¸°ë³¸ ë°ê¸°
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // âœ… HemisphereLight: ìì—°ìŠ¤ëŸ¬ìš´ ìƒ/í•˜ ë°©í–¥ ì¡°ëª…
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      // âœ… DirectionalLight: ì¹´ë©”ë¼ ê¸°ì¤€ ë™ê¸°í™” (ë©”ì¸ ë¼ì´íŠ¸)
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(0, 200, 200);
      scene.add(mainLight);

      // âœ… ë¼ì´íŠ¸ í—¬í¼ (ê°œë°œìš©)
      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(50, 100, 50);
      scene.add(light);

      // âœ… í—¬í¼ ì¶”ê°€ (í¬ê¸° 5)
      const helper = new THREE.DirectionalLightHelper(light, 5);
      scene.add(helper);

      // âœ… TrackballControls ì„¤ì •
      controls = new TrackballControls(camera, canvas);
      controls.rotateSpeed = 4.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;

      // âœ… ì¹´ë©”ë¼ ì›€ì§ì„ â†’ ë¼ì´íŠ¸ ìœ„ì¹˜ ë™ê¸°í™”
      controls.addEventListener('change', () => {
        mainLight.position.copy(camera.position.clone().add(new THREE.Vector3(0, 100, 100)));
        mainLight.lookAt(scene.position);
      });

      // âœ… ì¶• í‘œì‹œ + ë¼ë²¨
      const axisGroup = new THREE.Group();
      const axesHelper = new THREE.AxesHelper(500);
      axisGroup.add(axesHelper);

      const makeLabel = (text, color, position) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 64;
        ctx.fillStyle = color;
        ctx.font = 'bold 100px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(20, 20, 1);
        sprite.position.copy(position);
        return sprite;
      };

      scene.add(makeLabel('X', 'red', new THREE.Vector3(500, 0, 0)));   // +X (Right)
      scene.add(makeLabel('Y', 'blue', new THREE.Vector3(0, 500, 0))); // +y (Anterior)
      scene.add(makeLabel('Z', 'green', new THREE.Vector3(0, 0, 500))); // +Z (Superior)

      scene.add(makeLabel('L', 'red', new THREE.Vector3(250, 0, 0)));   // +X (Right)
      scene.add(makeLabel('P', 'blue', new THREE.Vector3(0, 250, 0))); // +y (Anterior)
      scene.add(makeLabel('S', 'green', new THREE.Vector3(0, 0, 250))); // +Z (Superior)

      scene.add(axisGroup);
    }

    const input = document.getElementById('dicomInput');
    const status = document.getElementById('status');

    input.addEventListener('change', async (e) => {
      try {
        const { niiUrl, nrrdUrl } = await uploadAndInferDicomBundle(
          e.target.files,
          'http://127.0.0.1:5000/infer-dicom-bundle',
          (msg) => status.textContent = msg
        );

        console.log('NIfTI URL:', niiUrl);
        console.log('NRRD URL:', nrrdUrl);

        // âœ… ë©”ì‹œ ìƒì„± ë° threeMeshes ì „ì—­ ì„¤ì •
        const meshes = await renderNrrdMesh(scene, camera, renderer, nrrdUrl);
        initMeshMap(meshes);
        buildMeshControllers(meshes);
        addMeshsToScene(meshes);
        // ì¹´ë©”ë¼ ë§ì¶¤
        if (meshes.length > 0) {
          fitCameraToMeshes(meshes, camera, controls);
        }

        threeMeshes = meshes;
        meshes.forEach(m => {
          meshMap[m.userData.label] = m;
        });
        

        // âœ… Niivue ì´ˆê¸°í™” (ì´í›„ ì¹´ë©”ë¼ ë™ê¸°í™” ì§„í–‰)
        await showTopVolumeOnly(nrrdUrl);
        await initTopLeftView(niiUrl, nrrdUrl);
        await showMultiVolumeView(niiUrl, nrrdUrl);

        // âœ… ì¹´ë©”ë¼ ë° í†µê³„ ì¶œë ¥
        logVolumeAndMeshStats(nvRender, camera, controls);

      } catch (err) {
        console.error(err);
        status.textContent = `âŒ ì˜¤ë¥˜: ${err.message}`;
      }
    });

    function initMeshMap(meshes) {
      meshMap = {};
      meshes.forEach(m => {
        meshMap[m.userData.label] = m;
      });
    }

    window.initMeshMap = initMeshMap;

    async function loadTestVolumes() {
      const [niiBlob, nrrdBlob] = await Promise.all([
        fetch('./data/converted.nii.gz').then(res => res.blob()),
        fetch('./data/inferred.nrrd').then(res => res.blob())
      ]);

      const nrrdUrl = URL.createObjectURL(nrrdBlob);
      niiUrl = URL.createObjectURL(niiBlob);

      // âœ… ë©”ì‹œ ìƒì„± ë° threeMeshes ì „ì—­ ì„¤ì •
      const meshes = await renderNrrdMesh(scene, camera, renderer, nrrdUrl);
      console.log("ğŸ§ª meshes ê°’:", meshes);
      console.log("ğŸ§ª typeof:", typeof meshes);
      console.log("ğŸ§ª Array.isArray(meshes):", Array.isArray(meshes));

      threeMeshes = meshes;
      initMeshMap(meshes);
      buildMeshControllers(meshes);
      addMeshsToScene(meshes);

      // ì¹´ë©”ë¼ ë§ì¶¤
      if (meshes.length > 0) {
        fitCameraToMeshes(meshes, camera, controls);
      }

      threeMeshes = meshes;

      // âœ… Niivue ì´ˆê¸°í™” (ì´í›„ ì¹´ë©”ë¼ ë™ê¸°í™” ì§„í–‰)
      await showTopVolumeOnly(nrrdUrl, labelColorMap1);
      const bottomView = await showMultiVolumeView(niiUrl, nrrdUrl, labelColorMap1);
      // await initTopLeftView(niiUrl, nrrdUrl);
      const topLeftView = await createTopLeftFromAnotherView(bottomView);

      bottomView.broadcastTo([topLeftView], { "2d": true, "3d": true });
      topLeftView.broadcastTo([bottomView], { "2d": true, "3d": true });

      lassoEditor.setRenderInstance(nvRender);
      lassoEditor.setMultiInstance(nvMulti);
      lassoEditor.setTopLeftView(topLeftView);

      console.log("ğŸ“¦ Loaded volumes in nvMulti:", nvMulti?.volumes);
      
      if (!nvMulti || nvMulti.volumes.length < 2) {
        console.warn("âš ï¸ Niivueì— ë³¼ë¥¨ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
      } else {
        console.log("âœ… ë³¼ë¥¨ ë¡œë“œ ì™„ë£Œ:", nvMulti.volumes.map(v => v.name));
      }

      // ë³¼ë¥¨ì˜ ê³µê°„ìƒì˜ ìœ„ì¹˜ê°€ ì˜ ë˜ì–´ìˆëŠ”ì§€ í™•ì¸ì„ ìœ„í•œ ë°”ìš´ë”© ë°•ìŠ¤
      // showVolumeBoundingBox(nvRender.volumes[0])
      
      logVolumeAndMeshStats(nvRender, camera, controls);
    }

    function showVolumeBoundingBox(volume)
    {
      const origin = lassoEditor.voxelToWorldCoordinates(0, 0, 0, volume);
      const maxDims = volume.hdr.dims.slice(1);
      const boundingMax = lassoEditor.voxelToWorldCoordinates(
        maxDims[0], maxDims[1], maxDims[2], 
        volume);

      console.log("ğŸ“ Origin in world coordinates:", origin, boundingMax);

      const box = new THREE.Box3(
        origin,
        boundingMax
      );
      const helper = new THREE.Box3Helper(box, 0x00ffcc);
      scene.add(helper);

    }


    let cameraAlreadySynced = false; // ìµœì´ˆ ë™ê¸°í™” ì—¬ë¶€ ì „ì—­ ìƒíƒœ

    function makeNiivueColormapFromLabelColorMap(labelColorMap) {
      const I = [], R = [], G = [], B = [], A = [];

      for (let i = 0; i <= 255; i++) {
        I.push(i);
        if (labelColorMap[i]) {
          const [r, g, b, a] = labelColorMap[i];
          R.push(r);
          G.push(g);
          B.push(b);
          A.push(a);
        } else {
          R.push(0);
          G.push(0);
          B.push(0);
          A.push(0);
        }
      }

      console.log("ğŸ§© ì™„ì„±ëœ Colormap:", { I, R: R.slice(0, 16), G: G.slice(0, 16), B: B.slice(0, 16), A: A.slice(0, 16) });
      return { I, R, G, B, A };
    }

    async function showTopVolumeOnly(nrrdUrl, labelColorMap1) {
      console.log("ğŸš€ ~ showTopVolumeOnly ~ labelColorMap:", labelColorMap1);

      nvRender = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.RENDER,
        backColor: [0, 0, 0, 1],
        dragAndDropEnabled: false,
        isOrientCube: true,
      });

      await nvRender.attachTo("canvasMulti");

      // âœ… Niivue ê¸°ë³¸ ë°©í–¥ ì„¤ì •
      nvRender.scene.renderAzimuth = 180;

      // âœ… 1. labelColorMap â†’ Niivue Colormap ìƒì„±
      const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap1);
      niivue.cmapper.addColormap("seg", segCmap);

      // âœ… 2. ìµœëŒ€ ë¼ë²¨ ê°’ ê¸°ë°˜ Niivue LUT ìƒì„±
      const maxLabelValue = Math.max(...Object.keys(labelColorMap1).map(Number));
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);

      // âœ… 3. ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ ì •ì˜
      const volumeList = [
        {
          url: nrrdUrl,
          name: "Seg.nrrd",
          colormap: "seg",      // âœ… ìš°ë¦¬ê°€ ë§Œë“  colormap ì‚¬ìš©
          indexedColors: true,
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 1.0,
          alphaThreshold: 0.0,
          visible: true,
        }
      ];

      // âœ… 4. ë³¼ë¥¨ ë¡œë“œ
      await nvRender.loadVolumes(volumeList);

      // âœ… 5. LUT ì ìš© â†’ ë°˜ë“œì‹œ labelLUT ì‚¬ìš©
      const segVolume = nvRender.volumes[0];
      segVolume.lut = labelLUT.lut;
      segVolume.cal_min = labelLUT.min;
      segVolume.cal_max = labelLUT.max;

      nvRender.opts.saturation = 1.4;   // ìƒ‰ê° ì„ ëª…
      nvRender.opts.brightness = 0.3;   // ì „ì²´ ë°ê¸° ì¦ê°€

      nvRender.updateGLVolume();
      nvRender.drawScene();

      animate();
      // setCameraSyncronizer(nvRender);
    }

    function setCameraSyncronizer(nvRender) {
      let drawCount = 0;
      const drawInterval = setInterval(() => {
        nvRender.drawScene();
        drawCount++;

        const cam = nvRender.scene?.camera;

        if ((cam?.eye && cam?.lookAt) || drawCount > 30) {
          clearInterval(drawInterval);

          if (!cameraAlreadySynced) {
            syncCameraZoomFromThreeToNiivue(nvRender, camera, controls);
            cameraAlreadySynced = true;
          }

          controls.addEventListener("change", () => {
            syncCameraZoomFromThreeToNiivue(nvRender, camera, controls);
          });

        }
      }, 200);
    }

    function syncCameraZoomFromThreeToNiivue(nvInstance, threeCamera, controls) {
      const eye = threeCamera.position.clone();
      const lookAt = controls.target.clone();
      const dir = eye.clone().sub(lookAt).normalize();

      const azimuth = Math.atan2(dir.x, dir.z) * (180 / Math.PI);
      const elevation = Math.asin(dir.y) * (180 / Math.PI);
      const distance = eye.distanceTo(lookAt); // Three.js ì¹´ë©”ë¼ ê±°ë¦¬

      // âœ… Niivue ì¹´ë©”ë¼ ì„¤ì •
      nvInstance.scene.renderAzimuth = (360 - azimuth + 360) % 360;
      nvInstance.scene.renderElevation = elevation;
      nvInstance.scene.cameraDistance = distance;

      // âœ… ë³¼ë¥¨ ì¤Œ(í¬ê¸°) ë³´ì • (ê±°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ì—­ë¹„ë¡€, ì¡°ì • ê°€ëŠ¥)
      const referenceDistance = 600; // ê¸°ì¤€ ê±°ë¦¬ (ì¡°ì • ê°€ëŠ¥)
      const multiplier = referenceDistance / distance;
      nvInstance.scene.volScaleMultiplier = multiplier;

      // âœ… camera.eye, lookAt ìˆ˜ë™ ì„¤ì •
      nvInstance.scene.camera = {
        eye: [eye.x, eye.y, eye.z],
        lookAt: [lookAt.x, lookAt.y, lookAt.z],
      };

      // âœ… ë·° ê°±ì‹ 
      nvInstance.drawScene();
    }

    function computeVolScaleMultiplier(nvInstance, meshBoundingBox) {
      const vol = nvInstance.volumes[0];
      const volDims = vol.dims;
      const pixDims = vol.pixDims;

      const volSize = {
        x: volDims[0] * pixDims[0],
        y: volDims[1] * pixDims[1],
        z: volDims[2] * pixDims[2],
      };

      const volumeMax = Math.max(volSize.x, volSize.y, volSize.z);

      const meshSize = new THREE.Vector3();
      meshBoundingBox.getSize(meshSize);
      const meshMax = Math.max(meshSize.x, meshSize.y, meshSize.z);

      return meshMax / volumeMax; // Niivue ìª½ì„ ë™ì¼í•˜ê²Œ ë§ì¶¤
    }

    function logVolumeAndMeshStats(nvInstance, threeCamera, controls) {
      // threeMeshesëŠ” ì „ì—­ì— ìˆëŠ” ê²ƒìœ¼ë¡œ ê°€ì •
      if (!threeMeshes || threeMeshes.length === 0) {
        console.warn("âš ï¸ ì „ì—­ threeMeshesê°€ ë¹„ì–´ìˆìŒ");
        return;
      }

      // --- Niivue Volume Bounding Box (ìˆ˜ë™ ê³„ì‚°) ---
      try {
        console.log("Number of Volumes", nvInstance?.volumes?.length);
        const vol = nvInstance?.volumes?.[0];
        if (vol?.hdr?.dims && vol?.hdr?.pixDims) {
          const dims = vol.hdr.dims;      // [dim0, x, y, z]
          const pixDims = vol.hdr.pixDims; // [_, dx, dy, dz]

          console.log("unit mm per voxel", pixDims);

          const sizeNii = {
            x: dims[1] * pixDims[1],
            y: dims[2] * pixDims[2],
            z: dims[3] * pixDims[3],
          };
          console.log("ğŸ“¦ Niivue Volume Size (manual)");
          // Niivue ê¸°ì¤€ ì¤‘ì‹¬ì 
          console.log("ğŸ§­ Niivue volume.mmCenter:", vol.mmCenter);

          console.log("  â†ªï¸ dims:", dims.slice(1));
          console.log("  â†ªï¸ pixDims:", pixDims.slice(1));
          console.log("  â†ªï¸ size (mm):", sizeNii);
        } else {
          console.warn("âš ï¸ Niivue ë³¼ë¥¨ ì •ë³´ ì—†ìŒ ë˜ëŠ” ë¶ˆì™„ì „");
        }
      } catch (e) {
        console.warn("âš ï¸ Niivue BoundingBox ê³„ì‚° ì˜¤ë¥˜:", e.message);
      }

      // --- Three.js Mesh Bounding Box ---
      try {
        const fullBox = new THREE.Box3();
        threeMeshes.forEach(obj => {
          if (obj instanceof THREE.Object3D) {
            fullBox.expandByObject(obj);
          }
        });
        const sizeMesh = new THREE.Vector3();
        fullBox.getSize(sizeMesh);
      } catch (e) {
        console.warn("âš ï¸ Three.js BoundingBox ì˜¤ë¥˜:", e.message);
      }

      // --- Niivue ì¹´ë©”ë¼ ê±°ë¦¬ / ìŠ¤ì¼€ì¼ ---
      if (nvInstance?.scene) {
        console.log("ğŸ“· Niivue ì¹´ë©”ë¼ ì •ë³´");
        console.log("  â†ªï¸ cameraDistance:", nvInstance.scene.cameraDistance);
        console.log("  â†ªï¸ volScaleMultiplier:", nvInstance.scene.volScaleMultiplier?.toFixed(3));
      }

      // --- Three.js ì¹´ë©”ë¼ ìœ„ì¹˜ ---
      if (threeCamera) {
        const eye = threeCamera.position;
        console.log("ğŸ“· Three.js ì¹´ë©”ë¼ eye:", eye.toArray());
      }

      // --- Three.js ì»¨íŠ¸ë¡¤ íƒ€ê²Ÿ ìœ„ì¹˜ ---
      if (controls?.target) {
        console.log("ğŸ“· controls.target:", controls.target.toArray());
      } else {
        console.warn("âš ï¸ controls.target ì •ë³´ ì—†ìŒ");
      }
    }

    function applyNiivueCustomColors(nvInstance) {
      if (!nvInstance || !nvInstance.volumes[1]) {
        console.warn("âš ï¸ Niivue ë˜ëŠ” Seg ë³¼ë¥¨ì´ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ");
        return;
      }

      const lut = new Uint8Array(256 * 4);
      lut.fill(0);

      Object.entries(labelColorMap).forEach(([labelIndex, rgb]) => {
        const idx = parseInt(labelIndex);
        if (!isNaN(idx)) {
          lut[idx * 4 + 0] = rgb[0];
          lut[idx * 4 + 1] = rgb[1];
          lut[idx * 4 + 2] = rgb[2];
          lut[idx * 4 + 3] = 255;
        }
      });

      nvInstance.volumes[1].colormapLabel = "custom";
      nvInstance.volumes[1].lut = lut;

      nvInstance.drawScene(); // âœ… updateGLVolume() ì œê±°
      console.log("âœ… Niivue LUT ì ìš© ì™„ë£Œ");
    }

    async function initTopLeftView(niiUrl, nrrdUrl) {
      const leftTopPlane = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.AXIAL,
        backColor: [0, 0, 0, 1],
        dragAndDropEnabled: false,
        isOrientCube: true,
      });

      await leftTopPlane.attachTo("leftTop");

      // âœ… ì„œë²„ ìƒ‰ìƒ ê¸°ë°˜ Niivue colormap ìƒì„±
      const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap1);
      niivue.cmapper.addColormap("seg", segCmap);

      // âœ… ìµœëŒ€ ë¼ë²¨ ê°’ ê³„ì‚°
      const maxLabelValue = Math.max(...Object.keys(labelColorMap1).map(Number));
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);

      console.log("ğŸš€ labelLUT:", labelLUT);

      const volumeList = [
        {
          url: niiUrl,
          name: "CT.nii.gz",
          colormap: "gray",
          opacity: 1,
          visible: true,
        },
        {
          url: nrrdUrl,
          name: "Seg.nrrd",
          colormap: "seg",       // âœ… ì»¤ìŠ¤í…€ ì»¬ëŸ¬ë§µ
          indexedColors: true,
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 0.8,
          alphaThreshold: 0.0,
          visible: true,
        },
      ];

      await leftTopPlane.loadVolumes(volumeList);

      // âœ… LUT ì ìš©
      const segVolume = leftTopPlane.volumes[1];
      segVolume.lut = labelLUT.lut;
      segVolume.cal_min = labelLUT.min;
      segVolume.cal_max = labelLUT.max;

      leftTopPlane.updateGLVolume();
      leftTopPlane.drawScene();

      console.log("âœ… ë©€í‹°í”Œë ˆì¸ ë·°ì–´ ë¡œë”© ì™„ë£Œ");
      return leftTopPlane;
    }

    // ë‹¤ë¥¸ niivue ì˜ volume ë“¤ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ Niivue ë¥¼ ë§Œë“ ë‹¤.
    async function createTopLeftFromAnotherView(niiVue) {
      const leftTopPlane = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.AXIAL,
        backColor: [0, 0, 0, 1],
        dragAndDropEnabled: false,
        isOrientCube: true,
      });

      await leftTopPlane.attachTo("leftTop");

      leftTopPlane.addVolume(niiVue.volumes[0]);
      leftTopPlane.addVolume(niiVue.volumes[1]);

      return leftTopPlane;
    }

    async function showMultiVolumeView(niiUrl, nrrdUrl) {
      nvMulti = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.MULTIPLANE,
        backColor: [0, 0, 0, 1],
        dragAndDropEnabled: false,
        isOrientCube: true,
      });

      const customLayout = [
        { sliceType: niivue.SLICE_TYPE.CORONAL, position: [0.0, 0, 0.5, 1.0] },
        { sliceType: niivue.SLICE_TYPE.SAGITTAL, position: [0.5, 0, 0.5, 1.0] },
      ];

      nvMulti.setCustomLayout(customLayout);

      await nvMulti.attachTo("canvasTop");

      // âœ… ì„œë²„ ìƒ‰ìƒ ê¸°ë°˜ Niivue colormap ìƒì„±
      const segCmap = makeNiivueColormapFromLabelColorMap(labelColorMap1);
      niivue.cmapper.addColormap("seg", segCmap);

      // âœ… ìµœëŒ€ ë¼ë²¨ ê°’ ê³„ì‚°
      const maxLabelValue = Math.max(...Object.keys(labelColorMap1).map(Number));
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, maxLabelValue);

      console.log("ğŸš€ labelLUT:", labelLUT);

      const volumeList = [
        {
          url: niiUrl,
          name: "CT.nii.gz",
          colormap: "gray",
          opacity: 1,
          visible: true,
        },
        {
          url: nrrdUrl,
          name: "Seg.nrrd",
          colormap: "seg",       // âœ… ì»¤ìŠ¤í…€ ì»¬ëŸ¬ë§µ
          indexedColors: true,
          cal_min: labelLUT.min,
          cal_max: labelLUT.max,
          opacity: 0.8,
          alphaThreshold: 0.0,
          visible: true,
        },
      ];

      await nvMulti.loadVolumes(volumeList);

      // âœ… LUT ì ìš©
      const segVolume = nvMulti.volumes[1];
      segVolume.lut = labelLUT.lut;
      segVolume.cal_min = labelLUT.min;
      segVolume.cal_max = labelLUT.max;

      nvMulti.updateGLVolume();
      nvMulti.drawScene();

      console.log("âœ… ë©€í‹°í”Œë ˆì¸ ë·°ì–´ ë¡œë”© ì™„ë£Œ");
      return nvMulti;
    }

    async function waitForNiivueReady(nvInstance, timeout = 500) {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        const check = () => {
          if (nvInstance.volumes[1]?.gl) {
            resolve();
          } else if (Date.now() - start > timeout) {
            reject(new Error("Niivue ì´ˆê¸°í™” ëŒ€ê¸° ì‹œê°„ ì´ˆê³¼"));
          } else {
            requestAnimationFrame(check);
          }
        };
        check();
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function buildMeshControllers(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      console.log(meshListDiv.children);

      meshes.forEach((mesh, idx) => {
        if (!mesh.material) return;

        // ì”¬ì— ì¶”ê°€
        if (!scene.children.includes(mesh)) {
          scene.add(mesh);
        }

        // UI í–‰ ì¶”ê°€
        const row = createMeshRowWithControls(mesh, idx);
        meshListDiv.appendChild(row);
      });
    }

    function addMeshsToScene(meshes) {
      meshes.forEach(mesh => {
        if (!mesh.material) return;
        
        scene.add(mesh);
      });
    }

    function bindMeshControllers(meshes) {
      const meshListDiv = document.getElementById('meshList');
      Array.from(meshListDiv.children).forEach(row => {
        const meshId = row.dataset.meshId;
        const mesh = meshes.find(m => m.uuid === meshId);
        if (!mesh) return;

        // ê°€ì‹œì„± í† ê¸€
        const visibilityCheckbox = row.querySelector('input[type="checkbox"]');
        visibilityCheckbox.checked = mesh.visible;
        visibilityCheckbox.onchange = () => {
          mesh.visible = visibilityCheckbox.checked;
          renderer.render(scene, camera);
        };

        // ë¶ˆíˆ¬ëª…ë„ ìŠ¬ë¼ì´ë”
        const opacitySlider = row.querySelector('input[type="range"]');
        opacitySlider.value = mesh.material.opacity;
        opacitySlider.oninput = () => {
          mesh.material.opacity = parseFloat(opacitySlider.value);
          mesh.material.transparent = mesh.material.opacity < 1.0;
          renderer.render(scene, camera);
        };
      });
    }

    window.buildMeshControllers = buildMeshControllers;
    window.addMeshsToScene = addMeshsToScene;
    window.bindMeshControllers = bindMeshControllers;

    // ì´ ìœ„ì¹˜ (ë˜ëŠ” ì ì ˆí•œ ë‹¤ë¥¸ ìœ„ì¹˜)ì— ì¶”ê°€í•˜ì„¸ìš”.
    function fitCameraToMeshes(meshes, camera, controls) {
      if (!meshes || meshes.length === 0) {
        console.warn("fitCameraToMeshes: ì¹´ë©”ë¼ë¥¼ ë§ì¶œ ë©”ì‹œê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      const bbox = new THREE.Box3();
      meshes.forEach(mesh => {
        // ë©”ì‹œê°€ THREE.Object3Dì˜ ì¸ìŠ¤í„´ìŠ¤ì´ê³  geometryë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
        if (mesh instanceof THREE.Object3D && mesh.geometry) {
          // ë©”ì‹œì˜ ë°”ìš´ë”© ë°•ìŠ¤ë¥¼ ê³„ì‚°í•˜ê³  ì›”ë“œ ë³€í™˜ì„ ì ìš©í•˜ì—¬ ì „ì²´ ë°”ìš´ë”© ë°•ìŠ¤ì— í†µí•©
          // (OBJLoaderê°€ Groupì„ ë°˜í™˜í•˜ê³  ê·¸ ì•ˆì— Meshê°€ ìˆëŠ” ê²½ìš°ë¥¼ ê³ ë ¤í•˜ì—¬ traverse ì‚¬ìš©ì„ ê³ ë ¤í•  ìˆ˜ë„ ìˆì§€ë§Œ,
          // ì—¬ê¸°ì„œëŠ” ì´ë¯¸ ê°œë³„ Mesh ê°ì²´ë“¤ì„ 'meshes' ë°°ì—´ì— ë‹´ì•˜ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.)
          mesh.geometry.computeBoundingBox();
          // mesh.matrixWorldëŠ” Object3Dì˜ ì „ì—­ ìœ„ì¹˜, íšŒì „, ìŠ¤ì¼€ì¼ì„ ë°˜ì˜í•©ë‹ˆë‹¤.
          // ì´ê²ƒì€ meshê°€ Group ì•ˆì— ìˆì„ ë•Œ íŠ¹íˆ ì¤‘ìš”í•©ë‹ˆë‹¤.
          bbox.union(mesh.geometry.boundingBox.clone().applyMatrix4(mesh.matrixWorld));
        }
      });

      if (bbox.isEmpty()) {
        console.warn("fitCameraToMeshes: ë°”ìš´ë”© ë°•ìŠ¤ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ë¥¼ ë§ì¶œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      const center = new THREE.Vector3();
      bbox.getCenter(center);
      controls.target.copy(center); // OrbitControls/TrackballControlsì˜ ì‹œì (lookAt)ì„ ë©”ì‹œì˜ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ì •

      const size = new THREE.Vector3();
      bbox.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z); // ë©”ì‹œì˜ ê°€ì¥ í° ì°¨ì›

      // ì¹´ë©”ë¼ì˜ FOV(ì‹œì•¼ê°)ë¥¼ ê³ ë ¤í•˜ì—¬ ë©”ì‹œ ì „ì²´ê°€ ë³´ì´ë„ë¡ ì¹´ë©”ë¼ Z ìœ„ì¹˜ ê³„ì‚°
      const fov = camera.fov * (Math.PI / 180); // FOVë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ ë³€í™˜
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

      // ì•½ê°„ì˜ ì—¬ìœ  ê³µê°„(ë²„í¼)ì„ ë‘ì–´ ë©”ì‹œê°€ ë„ˆë¬´ ê°€ë“ ì°¨ ë³´ì´ì§€ ì•Šë„ë¡ í•¨
      cameraZ *= 1.5; // ì´ ê°’ì€ ë©”ì‹œ í¬ê¸°ì— ë”°ë¼ ì¡°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (1.2 ~ 2.0 ì •ë„).

      // ì¹´ë©”ë¼ ìœ„ì¹˜ë¥¼ ë©”ì‹œì˜ ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
      camera.position.copy(center);
      camera.position.z += cameraZ;
      camera.position.y += cameraZ * 0.5; // ì•½ê°„ ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³´ëŠ” ëŠë‚Œ
      camera.position.x += cameraZ * 0.5; // ì•½ê°„ ì˜†ì—ì„œ ë°”ë¼ë³´ëŠ” ëŠë‚Œ

      camera.lookAt(center); // ì¹´ë©”ë¼ê°€ ë©”ì‹œì˜ ì¤‘ì‹¬ì„ ë°”ë¼ë³´ë„ë¡ ì„¤ì •
      controls.update(); // ì»¨íŠ¸ë¡¤ëŸ¬ ì—…ë°ì´íŠ¸ (ì¹´ë©”ë¼ ìœ„ì¹˜ ë³€ê²½ì„ ì»¨íŠ¸ë¡¤ëŸ¬ì— ë°˜ì˜)
      renderer.render(scene, camera); // ì”¬ ë Œë”ë§
      console.log("âœ… ë©”ì‹œì— ì¹´ë©”ë¼ ë§ì¶¤ ì™„ë£Œ.");
    }

    function createMeshRowWithControls(mesh, idx) {
      const labelValue = mesh.label || mesh.userData?.label;
      const labelText = label_name_mapping[labelValue] || `Label ${labelValue}`;
      const row = document.createElement('div');

      row.classList.add('mesh-row');

      // âœ… mesh.uuidë¥¼ datasetì— ì €ì¥
      row.dataset.meshId = mesh.uuid;
      row.dataset.label = labelValue;

      Object.assign(row.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        background: '#1A1A1A',
        borderRadius: '8px',
        padding: '8px 12px',
        marginBottom: '8px',
        cursor: 'pointer',
      });

      row.onclick = () => {
        const mesh = getMeshByLabel(row.dataset.label);
        selectMesh(mesh); // âœ… ê¸°ì¡´ í•¨ìˆ˜ ì‚¬ìš©
        selectedMesh = mesh;
        undoStack = [];

        highlightSelectedMesh(mesh);
      };

      const left = createLeftLabelSection(mesh, labelText);
      row.appendChild(left);
      
      const controlPanel = createVisibilityAndOpacityControl(row.dataset);
      row.appendChild(controlPanel);
      return row;
    }

    function createLeftLabelSection(mesh, labelText) {
      const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);

      const container = document.createElement('div');
      Object.assign(container.style, {
        display: 'flex',
        alignItems: 'center',
        flex: '1',
      });

      const colorBox = document.createElement('div');
      Object.assign(colorBox.style, {
        width: '12px',
        height: '12px',
        borderRadius: '50%',
        background: `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`,
        marginRight: '8px',
      });
      container.appendChild(colorBox);

      const label = document.createElement('span');
      label.innerText = labelText;
      Object.assign(label.style, {
        color: '#fff',
        fontSize: '14px',
        flex: '1',
      });
      container.appendChild(label);

      return container;
    }

    function getMeshByLabel(label) {
      return meshMap[label];
    }

    function createVisibilityAndOpacityControl(dataset) {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.justifyContent = 'space-between';
      container.style.gap = '12px';
      container.style.flex = '1';

      // ì™¼ìª½: ìŠ¬ë¼ì´ë” + ìˆ«ì
      const sliderGroup = document.createElement('div');
      sliderGroup.style.display = 'flex';
      sliderGroup.style.alignItems = 'center';
      sliderGroup.style.gap = '8px';

      console.log("ğŸ›ï¸ dataset:", dataset);
      const mesh = getMeshByLabel(dataset.label);
      const initialOpacity = mesh.material.opacity ?? 1;
      mesh.material.opacity = initialOpacity;

      const slider = document.createElement('input');
      Object.assign(slider, {
        type: 'range',
        min: 0,
        max: 1,
        step: 0.01,
        value: initialOpacity,
        title: 'íˆ¬ëª…ë„ ì¡°ì ˆ',
      });
      slider.style.width = '60px';

      const valueText = document.createElement('span');
      valueText.innerText = initialOpacity.toFixed(2);
      valueText.style.fontSize = '12px';
      valueText.style.color = 'white';
      valueText.style.width = '32px';
      valueText.style.textAlign = 'right';

      slider.oninput = (e) => {
        const targetMesh = getMeshByLabel(dataset.label);
        const val = parseFloat(e.target.value);
        targetMesh.material.opacity = val;
        valueText.innerText = val.toFixed(2);

        if (val < 1.0) {
          Object.assign(targetMesh.material, {
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.NormalBlending
          });
        } else {
          Object.assign(targetMesh.material, {
            transparent: false,
            depthWrite: true,
            side: THREE.DoubleSide,
            blending: THREE.NoBlending
          });
        }

        targetMesh.material.needsUpdate = true;
      };

      sliderGroup.appendChild(slider);
      sliderGroup.appendChild(valueText);

      // ì˜¤ë¥¸ìª½: eye ì•„ì´ì½˜
      const eye = document.createElement('span');
      eye.style.cursor = 'pointer';
      eye.style.fontSize = '12px';
      eye.style.color = 'white';

      const updateIcon = () => {
        eye.innerHTML = mesh.visible
          ? '<i class="fa-regular fa-eye"></i>'
          : '<i class="fa-regular fa-eye-slash"></i>';
      };

      eye.onclick = (e) => {
        const targetMesh = getMeshByLabel(dataset.label);
        e.stopPropagation();
        targetMesh.visible = !targetMesh.visible;
        updateIcon();
        light.position.copy(camera.position);
        renderer.render(scene, camera);
      };

      updateIcon();

      container.appendChild(sliderGroup); // ì™¼ìª½
      container.appendChild(eye);         // ì˜¤ë¥¸ìª½

      return container;
    }

    const lassoEditor = new LassoEditor(canvas, camera, renderer, scene, controls);

    // ğŸ¨ ì „ì—­ í•¨ìˆ˜ë¡œ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ ë…¸ì¶œ 
    // window.updateVolumeColors = () => {
    //   if (lassoEditor) {
    //     lassoEditor.updateVolumeColorsFromBackend();
    //   }
    // };

    // ì „ì—­ ë³€ìˆ˜ë¡œ editor ë…¸ì¶œ
    window.lassoEditor = lassoEditor;

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (lassoEditor.selectedMesh) {
        lassoEditor.undoManager.undo(lassoEditor.selectedMesh);
      }
    });

    const editorBtn = document.getElementById('editorBtn');
    const editModeBtn = document.getElementById('editModeBtn');
    const scissorIcon = document.getElementById('scissorIcon');

    // âœ… í¸ì§‘ ëª¨ë“œ ì „í™˜ ë²„íŠ¼
    editModeBtn.addEventListener('click', () => {
      lassoEditor.volumeEditFullMode = !lassoEditor.volumeEditFullMode;

      // if (lassoEditor.volumeEditFullMode) {
      //   editModeBtn.textContent = 'ğŸŒ ì „ì²´';
      //   editModeBtn.style.background = '#222';
      //   console.log('ğŸ”§ í¸ì§‘ ëª¨ë“œ: ì „ì²´ í¸ì§‘');
      // } else {
      //   editModeBtn.textContent = 'ğŸ¯ ë¶€ë¶„';
      //   editModeBtn.style.background = '#0066cc';
      //   console.log('ğŸ”§ í¸ì§‘ ëª¨ë“œ: ë¶€ë¶„ í¸ì§‘');
      // }

      if (!lassoEditor.volumeEditFullMode) {
        editModeBtn.textContent = 'ğŸ¯ ë¶€ë¶„';
        editModeBtn.style.background = '#0066cc';
      } else {
        editModeBtn.textContent = 'ğŸŒ ì „ì²´';
        editModeBtn.style.background = '#222';
      }
    });

    editorBtn.addEventListener('click', () => {
      const isActive = !lassoEditor.editMode;
      lassoEditor.toggleEditMode(isActive);

      if (isActive) {
        editorBtn.textContent = 'âœ… í¸ì§‘ ì¤‘ (í´ë¦­í•´ì„œ ì¢…ë£Œ)';
        editorBtn.classList.add('edit-active');
        scissorIcon.style.display = 'block';

        // âœ… selectedMeshê°€ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ë©”ì‰¬ ìë™ ì„ íƒ
        if (!selectedMesh && threeMeshes.length > 0) {
          selectMesh(threeMeshes[0]); // ë‚´ë¶€ì ìœ¼ë¡œ highlight ì²˜ë¦¬
        } else if (selectedMesh) {
          highlightSelectedMesh(selectedMesh);
        }
      } else {
        editorBtn.textContent = 'âœ‚ï¸ í¸ì§‘ ëª¨ë“œ';
        editorBtn.classList.remove('edit-active');
        scissorIcon.style.display = 'none';
        clearAllHighlights();
      }
    });

    function selectMesh(mesh) {
      lassoEditor.setSelectedMesh(mesh);
      selectedMesh = mesh;

      // create bounding box helper for mesh
      if (boundingBoxHelper != undefined) {
        scene.remove(boundingBoxHelper);
      }
      boundingBoxHelper = new THREE.BoxHelper(mesh, 0x00ffff);
      scene.add(boundingBoxHelper);

      // âœ… UI í•­ìƒ ì´ˆê¸°í™”
      clearAllHighlights();

      // âœ… í¸ì§‘ ëª¨ë“œë¼ë©´ ì¦‰ì‹œ ê°•ì¡°
      if (lassoEditor.editMode) {
        highlightSelectedMesh(mesh);
      }
    }

    function highlightSelectedMesh(mesh) {
      clearAllHighlights();

      const rows = document.querySelectorAll('.mesh-row');
      rows.forEach(row => {
        if (row.dataset.meshId === mesh.uuid) {
          row.classList.add('selected-row');
        }
      });
    }

    function clearAllHighlights() {
      document
        .querySelectorAll('.mesh-row')
        .forEach(el => el.classList.remove('selected-row'));
    }

    const nv = new niivue.Niivue({
      sliceType: niivue.SLICE_TYPE.MULTIPLANE,
      backColor: [0, 0, 0, 1]
    });
    await nv.attachTo("canvasTop");

    // âœ… NRRD í—¤ë” íŒŒì‹± & ë¡œê·¸ ì¶œë ¥
    async function logNrrdHeader(blob) {
      const text = await blob.text();
      const header = text.split("\n\n")[0];
      console.log("===== [NRRD Header ë¡œê·¸] =====");
      console.log(header);
      console.log("â†’ sizes:", (header.match(/sizes:\s+([\d\s]+)/) || [])[1]);
      console.log("â†’ origin:", (header.match(/space origin:\s+\((.*?)\)/) || [])[1]);
    }

    // âœ… Niivue HDR ì •ë³´ ì¶œë ¥
    function logNiivueVolumeInfo(nvInstance) {
      try {
        const segVolume = nvInstance?.volumes?.[1];
        if (!segVolume) {
          console.warn("âš ï¸ Niivue Segmentation Volume ì—†ìŒ");
          return;
        }

        console.log("===== [Niivue HDR ë¡œê·¸] =====");
        console.log("dims:", segVolume.hdr.dims);
        console.log("pixDims:", segVolume.hdr.pixDims);
        console.log("srow_x:", segVolume.hdr.srow_x);
        console.log("srow_y:", segVolume.hdr.srow_y);
        console.log("srow_z:", segVolume.hdr.srow_z);
        console.log("mmCenter:", segVolume.mmCenter);
      } catch (err) {
        console.error("âŒ Niivue HDR ë¡œê·¸ ì¶œë ¥ ì‹¤íŒ¨:", err);
      }
    }
  </script>


  <style>
    .d-none {
      display: none;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 8px;
      box-shadow: 0 0 6px rgba(0, 123, 255, 0.3);
    }

    #editorBtn.edit-active {
      background: #007bff !important;
      /* íŒŒë€ìƒ‰ ê°•ì¡° */
      border: 2px solid #00aaff !important;
      color: white;
      font-weight: bold;
    }

    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
      background: black;
    }

    header {
      width: 100vw;
      height: 56px;
      /* í•„ìš”ì— ë”°ë¼ 40~80px */
      min-height: 40px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #meshSidebar {
      pointer-events: auto;
      z-index: 10;
      flex: 0 1 270px;
      min-width: 150px;
      border-right: 1px solid #ddd;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
      min-width: 270px;
    }

    #topHalf {
      display: flex;
      flex-direction: column;
      
      border-color: red;
      border-style: solid;
    }

    #bottomHalf {
      flex: 1;
      display: flex;
      flex-direction: column;

      border-color: red;
      border-style: solid;
    }

    #threeCanvas {
      pointer-events: auto;
      /* ë˜ëŠ” all */
      z-index: 1;
      
      width: 100%;
      height: 100%;
      display: flex;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 10px;
      box-shadow: 0 0 4px rgba(0, 123, 255, 0.3);
    }

    #mainLayout {
      display: flex;
      flex-direction: row;
      /* ëª…ì‹œì ìœ¼ë¡œ ì¢Œ-ì¤‘-ìš° ë°°ì¹˜ */
      width: 100vw;
      height: calc(100vh - 56px);
      /* overflow: hidden; */
    }

    #viewerArea {
      flex: 1 1 auto;
      /* ë‚¨ëŠ” ê³µê°„ ë‹¤ ì‚¬ìš© */
      min-width: 0;
      /* overflow ë°©ì§€ */
      display: flex;
      flex-direction: column;
      height: 100%;

    }

    #volumeTableArea {
      width: 300px;
      background: #000000;
      padding: 16px;
      border-left: 1px solid #ccc;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
      z-index: 1;
    }

    header button,
    header input[type="file"] {
      font-size: 14px;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      margin-right: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    header button:hover,
    header input[type="file"]:hover {
      background-color: #0056b3;
    }

    header button:active,
    header input[type="file"]:active {
      background-color: #004999;
    }

    header #status {
      font-size: 14px;
      color: white;
      margin-left: 12px;
    }

    #volumeTableContent table {
      width: 100%;
      border-collapse: collapse;
      font-size: 15px;
      border: 1px solid #ccc;
    }

    #volumeTableContent thead {
      background-color: #004c7f;
      /* ì¢€ ë” ê¹Šì€ ë¸”ë£¨ */
      color: white;
    }

    #volumeTableContent thead th {
      padding: 10px;
      border-bottom: 1px solid #ccc;
      text-align: left;
    }

    #volumeTableContent tbody tr:nth-child(even) {
      background-color: #f2f6f9;
    }

    #volumeTableContent tbody tr:nth-child(odd) {
      background-color: #e8eff5;
    }

    #volumeTableContent tbody td {
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    #volumeTableContent tbody tr:last-child {
      background-color: #e0f0ff;
      /* Total í–‰ ë°°ê²½ */
      font-weight: bold;
    }

    #volumeTableContent tbody tr:last-child td {
      color: #003366;
    }
  </style>
</body>

</html>