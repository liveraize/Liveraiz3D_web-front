<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 56px;
  padding: 0 20px;
  background-color: #111;
  border-bottom: 1px solid #444;
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-sizing: border-box;
">

    <!-- 좌측 -->


    <!-- 가운데 (로고 + 텍스트) -->
    <div style="
    display: flex;
    align-items: center;
    font-size: 20px;
    font-weight: bold;
    letter-spacing: 1px;
    gap: 10px;
  ">
      <!-- 심플 아이콘 -->
      <div style="
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff4e50, #f9d423);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: white;
      box-shadow: 0 0 4px rgba(0,0,0,0.4);
    ">
        L
      </div>
      <div>Liveraizer</div>
    </div>



    <!-- 우측 (버튼) -->
    <div style="display: flex; align-items: center;">
      <button id="undoBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">↩️</button>

      <button id="editorBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">✂️</button>


    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="file" id="folderInput" webkitdirectory multiple style="
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      font-size: 14px;
    " />
      <span id="status" style="font-size: 14px; color: #ccc;">진행 중 없음</span>
    </div>
    <input type="file" id="dicomInput" webkitdirectory multiple />
    <!-- <p id="status">상태 메시지</p> -->
  </header>
  <!-- <canvas id="canvasMulti" style="width:100%; height:100%"></canvas> -->

  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
    </div>
    <div id="viewerArea">
      <div id="viewerContentArea" style="flex:1; display:flex; flex-direction:column;">
        <div id="bottomHalf" style="position: relative;">
          <div id="labelContainer" style="position:absolute; top:0; left:0; pointer-events:none; z-index:20;"></div>
          <canvas id="threeCanvas"></canvas>
          <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
          <div id="scissorIcon" style="
            position: absolute;
            z-index: 100;
            pointer-events: none;
            display: none;
            font-size: 20px;
          ">✂️</div>
        </div>
        <div id="topHalf">
          <canvas id="canvasMulti"></canvas>
        </div>
      </div>
    </div>
    <div id="volumeTableArea">
      <div id="volumeTableContent"></div>
    </div>
  </div>
  <div id="topViewer" style="height: 300px;">
    <canvas id="canvasTop" style="width:100%; height:100%;"></canvas>
  </div>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>
  <script type="module">
    import JSZip from 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm';
    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { NRRDLoader } from 'three/examples/jsm/loaders/NRRDLoader.js';
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
    import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js';
    import { renderNrrdMesh } from './viewer/renderNrrdMesh.js';
    import { labelColorMap, labelNameMap } from './viewer/colorMaps.js';
    import { marchingCubes } from './utils/marchingCubes.js';
    import { uploadAndInferDicomBundle } from './upload/uploadAndInferDicomBundle.js';
    import * as niivue from '../dist/index.js'; // 또는 CDN 사용
    // import * as niivue from "https://unpkg.com/@niivue/niivue@latest/dist/index.js";
    // import * as niivue from "https://unpkg.com/@niivue/niivue@0.58.5/dist/index.js";
    let threeMeshes = [];
    let hiddenFaces = new Map();
    let undoStack = [];
    let lassoPoints = [];
    let lassoActive = false;
    let editMode = false;
    let lassoCanvas, ctx;
    let selectedMesh = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMesh = null;

    const canvas = document.getElementById('threeCanvas');
    let scene, camera, renderer;

    let controls = null;
    let nvMulti = null;     // 멀티플레인 뷰어
    let nvRender = null;    // 렌더 뷰어

    const label_name_mapping = {
      1: "Liver",
      2: "Rt.lobe",
      3: "RAS",
      4: "RPS",
      5: "Lt.lobe",
      6: "LLS",
      7: "LMS",
      8: "Spigelian",
      9: "PV",
      10: "HV",
      11: "Cancer",
      12: "BD"
    }
    initThreeJS()
    loadTestVolumes();

    function initThreeJS() {
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 5000);
      camera.position.set(0, 200, 400);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // ✅ AmbientLight: 전체적인 기본 밝기
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // ✅ HemisphereLight: 자연스러운 상/하 방향 조명
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      // ✅ DirectionalLight: 카메라 기준 동기화 (메인 라이트)
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(0, 200, 200);
      scene.add(mainLight);

      // ✅ 라이트 헬퍼 (개발용)
      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(50, 100, 50);
      scene.add(light);

      // ✅ 헬퍼 추가 (크기 5)
      const helper = new THREE.DirectionalLightHelper(light, 5);
      scene.add(helper);

      // ✅ TrackballControls 설정
      controls = new TrackballControls(camera, canvas);
      controls.rotateSpeed = 4.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;

      // ✅ 카메라 움직임 → 라이트 위치 동기화
      controls.addEventListener('change', () => {
        mainLight.position.copy(camera.position.clone().add(new THREE.Vector3(0, 100, 100)));
        mainLight.lookAt(scene.position);
      });

      // ✅ 축 표시 + 라벨
      const axisGroup = new THREE.Group();
      const axesHelper = new THREE.AxesHelper(100);
      axisGroup.add(axesHelper);

      const makeLabel = (text, color, position) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 64;
        ctx.fillStyle = color;
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(20, 20, 1);
        sprite.position.copy(position);
        return sprite;
      };

      scene.add(makeLabel('R', 'red', new THREE.Vector3(100, 0, 0)));   // +X (Right)
      scene.add(makeLabel('A', 'blue', new THREE.Vector3(0, 0, -100))); // -Z (Anterior)
      scene.add(makeLabel('S', 'green', new THREE.Vector3(0, 100, 0))); // +Y (Superior)

      axisGroup.rotation.x = -Math.PI / 2;
      scene.add(axisGroup);
    }

    const input = document.getElementById('dicomInput');
    const status = document.getElementById('status');

    input.addEventListener('change', async (e) => {
      try {
        const { niiUrl, nrrdUrl } = await uploadAndInferDicomBundle(
          e.target.files,
          'http://127.0.0.1:5000/infer-dicom-bundle',
          (msg) => status.textContent = msg
        );

        console.log('NIfTI URL:', niiUrl);
        console.log('NRRD URL:', nrrdUrl);


        // ✅ 메시 생성 및 threeMeshes 전역 설정
        const meshes = await renderNrrdMesh(scene, camera, renderer, nrrdUrl);
        renderThreeMeshListUI(meshes);
        threeMeshes = meshes;

        // ✅ Niivue 초기화 (이후 카메라 동기화 진행)
        await showTopVolumeOnly(nrrdUrl);
        await showMultiVolumeView(niiUrl, nrrdUrl);

        // ✅ 카메라 및 통계 출력
        logVolumeAndMeshStats(nvRender, camera, controls);

      } catch (err) {
        console.error(err);
        status.textContent = `❌ 오류: ${err.message}`;
      }
    });


    async function loadTestVolumes() {
      const [niiBlob, nrrdBlob] = await Promise.all([
        fetch('./data/converted.nii.gz').then(res => res.blob()),
        fetch('./data/inferred.nrrd').then(res => res.blob())
      ]);

      const nrrdUrl = URL.createObjectURL(nrrdBlob);
      const niiUrl = URL.createObjectURL(niiBlob);

      // ✅ 메시 생성 및 threeMeshes 전역 설정
      const meshes = await renderNrrdMesh(scene, camera, renderer, nrrdUrl);
      console.log("🧪 meshes 값:", meshes);
      console.log("🧪 typeof:", typeof meshes);
      console.log("🧪 Array.isArray(meshes):", Array.isArray(meshes));
      renderThreeMeshListUI(meshes);
      threeMeshes = meshes;

      // ✅ Niivue 초기화 (이후 카메라 동기화 진행)
      await showTopVolumeOnly(nrrdUrl);
      await showMultiVolumeView(niiUrl, nrrdUrl);

      // ✅ 카메라 및 통계 출력
      logVolumeAndMeshStats(nvRender, camera, controls);
    }


    let cameraAlreadySynced = false; // 최초 동기화 여부 전역 상태

    async function showTopVolumeOnly(nrrdUrl) {
      nvRender = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.RENDER,
        backColor: [0, 0, 0, 1],
        dragAndDropEnabled: false,
        isOrientCube: true,
      });

      await nvRender.attachTo("canvasMulti");

      const volumeList = [
        {
          url: nrrdUrl,
          name: "Seg.nrrd",
          colormap: "red",
          colormapLabel: "glasbey",
          opacity: 1,
          visible: true,
        }
      ];

      // Niivue 기본 방향
      nvRender.scene.renderAzimuth = 180;
      await nvRender.loadVolumes(volumeList);
      nvRender.drawScene();
      let drawCount = 0;
      const drawInterval = setInterval(() => {
        nvRender.drawScene();
        drawCount++;

        const cam = nvRender.scene?.camera;

        if ((cam?.eye && cam?.lookAt) || drawCount > 30) {
          clearInterval(drawInterval);

          // ✅ 최초 1회만 Three.js 카메라와 동기화
          if (!cameraAlreadySynced) {
            syncCameraZoomFromThreeToNiivue(nvRender, camera, controls);
            cameraAlreadySynced = true;
          }

          // 이후 카메라 조작은 자유롭게 (Niivue 동기화 없음)
          controls.addEventListener("change", () => {
            syncCameraZoomFromThreeToNiivue(nvRender, camera, controls);
          });

          animate(); // Three.js 렌더링 루프 시작
        }
      }, 200);
    }

    function syncCameraZoomFromThreeToNiivue(nvInstance, threeCamera, controls) {
      const eye = threeCamera.position.clone();
      const lookAt = controls.target.clone();
      const dir = eye.clone().sub(lookAt).normalize();

      const azimuth = Math.atan2(dir.x, dir.z) * (180 / Math.PI);
      const elevation = Math.asin(dir.y) * (180 / Math.PI);
      const distance = eye.distanceTo(lookAt); // Three.js 카메라 거리

      // ✅ Niivue 카메라 설정
      nvInstance.scene.renderAzimuth = (360 - azimuth + 360) % 360;
      nvInstance.scene.renderElevation = elevation;
      nvInstance.scene.cameraDistance = distance;

      // ✅ 볼륨 줌(크기) 보정 (거리 기준으로 역비례, 조정 가능)
      const referenceDistance = 600; // 기준 거리 (조정 가능)
      const multiplier = referenceDistance / distance;
      nvInstance.scene.volScaleMultiplier = multiplier;

      // ✅ camera.eye, lookAt 수동 설정
      nvInstance.scene.camera = {
        eye: [eye.x, eye.y, eye.z],
        lookAt: [lookAt.x, lookAt.y, lookAt.z],
      };

      // ✅ 뷰 갱신
      nvInstance.drawScene();
    }

    function computeVolScaleMultiplier(nvInstance, meshBoundingBox) {
      const vol = nvInstance.volumes[0];
      const volDims = vol.dims;
      const pixDims = vol.pixDims;

      const volSize = {
        x: volDims[0] * pixDims[0],
        y: volDims[1] * pixDims[1],
        z: volDims[2] * pixDims[2],
      };

      const volumeMax = Math.max(volSize.x, volSize.y, volSize.z);

      const meshSize = new THREE.Vector3();
      meshBoundingBox.getSize(meshSize);
      const meshMax = Math.max(meshSize.x, meshSize.y, meshSize.z);

      return meshMax / volumeMax; // Niivue 쪽을 동일하게 맞춤
    }



    function logVolumeAndMeshStats(nvInstance, threeCamera, controls) {
      // threeMeshes는 전역에 있는 것으로 가정
      if (!threeMeshes || threeMeshes.length === 0) {
        console.warn("⚠️ 전역 threeMeshes가 비어있음");
        return;
      }

      // --- Niivue Volume Bounding Box (수동 계산) ---
      try {
        const vol = nvInstance?.volumes?.[0];
        if (vol?.hdr?.dims && vol?.hdr?.pixDims) {
          const dims = vol.hdr.dims;      // [dim0, x, y, z]
          const pixDims = vol.hdr.pixDims; // [_, dx, dy, dz]

          const sizeNii = {
            x: dims[1] * pixDims[1],
            y: dims[2] * pixDims[2],
            z: dims[3] * pixDims[3],
          };
          console.log("📦 Niivue Volume Size (manual)");
          // Niivue 기준 중심점
          console.log("🧭 Niivue volume.mmCenter:", vol.mmCenter);

          console.log("  ↪️ dims:", dims.slice(1));
          console.log("  ↪️ pixDims:", pixDims.slice(1));
          console.log("  ↪️ size (mm):", sizeNii);
        } else {
          console.warn("⚠️ Niivue 볼륨 정보 없음 또는 불완전");
        }
      } catch (e) {
        console.warn("⚠️ Niivue BoundingBox 계산 오류:", e.message);
      }

      // --- Three.js Mesh Bounding Box ---
      try {
        const fullBox = new THREE.Box3();
        threeMeshes.forEach(obj => {
          if (obj instanceof THREE.Object3D) {
            fullBox.expandByObject(obj);
          }
        });
        const sizeMesh = new THREE.Vector3();
        fullBox.getSize(sizeMesh);
        console.log("📦 Three.js Mesh Bounding Box");
        console.log("  ↪️ min:", fullBox.min);
        console.log("  ↪️ max:", fullBox.max);
        console.log("  ↪️ size:", sizeMesh);
      } catch (e) {
        console.warn("⚠️ Three.js BoundingBox 오류:", e.message);
      }

      // --- Niivue 카메라 거리 / 스케일 ---
      if (nvInstance?.scene) {
        console.log("📷 Niivue 카메라 정보");
        console.log("  ↪️ cameraDistance:", nvInstance.scene.cameraDistance);
        console.log("  ↪️ volScaleMultiplier:", nvInstance.scene.volScaleMultiplier?.toFixed(3));
      }

      // --- Three.js 카메라 위치 ---
      if (threeCamera) {
        const eye = threeCamera.position;
        console.log("📷 Three.js 카메라 eye:", eye.toArray());
      }

      // --- Three.js 컨트롤 타겟 위치 ---
      if (controls?.target) {
        console.log("📷 controls.target:", controls.target.toArray());
      } else {
        console.warn("⚠️ controls.target 정보 없음");
      }
    }


    function applyNiivueCustomColors(nvInstance) {
      if (!nvInstance || !nvInstance.volumes[1]) {
        console.warn("⚠️ Niivue 또는 Seg 볼륨이 준비되지 않음");
        return;
      }

      const lut = new Uint8Array(256 * 4);
      lut.fill(0);

      Object.entries(labelColorMap).forEach(([labelIndex, rgb]) => {
        const idx = parseInt(labelIndex);
        if (!isNaN(idx)) {
          lut[idx * 4 + 0] = rgb[0];
          lut[idx * 4 + 1] = rgb[1];
          lut[idx * 4 + 2] = rgb[2];
          lut[idx * 4 + 3] = 255;
        }
      });

      nvInstance.volumes[1].colormapLabel = "custom";
      nvInstance.volumes[1].lut = lut;

      nvInstance.drawScene(); // ✅ updateGLVolume() 제거
      console.log("✅ Niivue LUT 적용 완료");
    }

    async function showMultiVolumeView(niiUrl, nrrdUrl) {
      nvMulti = new niivue.Niivue({
        sliceType: niivue.SLICE_TYPE.MULTIPLANE,
        backColor: [0, 0, 0, 1],
        dragAndDropEnabled: false,
        isOrientCube: true,
      });

      await nvMulti.attachTo("canvasTop");


      const segCmap = {
        R: [255, 255, 0, 0, 255, 128, 255],  // R 값 배열
        G: [0, 255, 255, 0, 128, 128, 0],    // G 값 배열
        B: [0, 0, 0, 255, 0, 255, 255],      // B 값 배열
        I: [0, 1, 2, 3, 4, 5, 6]            // 인덱스 값
      };
      const labelLUT = niivue.cmapper.makeLabelLut(segCmap, 255); // 라벨 최대값 맞춤
      console.log("🚀 ~ showMultiVolumeView ~ labelLUT:", labelLUT)

      const volumeList = [
        {
          url: niiUrl,
          name: "CT.nii.gz",
          colormap: "gray",
          opacity: 1,
          visible: true,
        },
        {
          url: nrrdUrl,
          name: "Seg.nrrd",
          colormap: "seg",          // Gray Scale용
          cal_min: labelLUT.min, cal_max: labelLUT.max,
          opacity: 0.5,
          visible: true,
        },
      ];

      await nvMulti.loadVolumes(volumeList);
      // applyNiivueCustomColors(nvMulti);

      // nvMulti.scene.renderAzimuth = 180;
      // nvMulti.scene.renderElevation = 0;
      nvMulti.scene.renderAzimuth = 180;
      nvMulti.scene.renderElevation = 0;

      const segVolume = nvMulti.volumes[1];
      segVolume.lut = labelLUT.lut;
      segVolume.cal_min = labelLUT.min;
      segVolume.cal_max = labelLUT.max;

      nvMulti.updateGLVolume();
      nvMulti.drawScene();

      const vol = nvMulti.volumes[0]; // CT 볼륨
      // vol.matRAS[0] *= -1;
      // vol.matRAS[3] *= -1; // X축 위치도 반전
      nvMulti.updateGLVolume();
      nvMulti.drawScene();
      // console.log("🧭 RAS 행렬 (matRAS):", vol.matRAS);
      // console.log("🧭 원래의 행렬 (hdr.qform/sform 등):", vol.hdr.srow_x, vol.hdr.srow_y, vol.hdr.srow_z);

      console.log("✅ 멀티플레인 뷰어 로딩 완료:");
      nvMulti.volumes.forEach((v, i) => {
        console.log(`📦 Volume ${i}: ${v.name}`);
      });

      return nvMulti; // 원한다면 외부에서 동기화용으로 사용
    }

    async function waitForNiivueReady(nvInstance, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        const check = () => {
          if (nvInstance.volumes[1]?.gl) {
            resolve();
          } else if (Date.now() - start > timeout) {
            reject(new Error("Niivue 초기화 대기 시간 초과"));
          } else {
            requestAnimationFrame(check);
          }
        };
        check();
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function renderThreeMeshListUI(meshes) {
      const meshListDiv = document.getElementById('meshList');
      meshListDiv.innerHTML = '';

      meshes.forEach((mesh, idx) => {
        if (!mesh.material) return;

        // 씬에 추가
        if (!scene.children.includes(mesh)) {
          scene.add(mesh);
        }

        // UI 행 추가
        const row = createMeshRowWithControls(mesh, idx);
        meshListDiv.appendChild(row);
      });

      // 카메라 맞춤
      if (meshes.length > 0) {
        fitCameraToMeshes(meshes, camera, controls);
      }
    }

    // 이 위치 (또는 적절한 다른 위치)에 추가하세요.
    function fitCameraToMeshes(meshes, camera, controls) {
      if (!meshes || meshes.length === 0) {
        console.warn("fitCameraToMeshes: 카메라를 맞출 메시가 없습니다.");
        return;
      }

      const bbox = new THREE.Box3();
      meshes.forEach(mesh => {
        // 메시가 THREE.Object3D의 인스턴스이고 geometry를 가지고 있는지 확인
        if (mesh instanceof THREE.Object3D && mesh.geometry) {
          // 메시의 바운딩 박스를 계산하고 월드 변환을 적용하여 전체 바운딩 박스에 통합
          // (OBJLoader가 Group을 반환하고 그 안에 Mesh가 있는 경우를 고려하여 traverse 사용을 고려할 수도 있지만,
          // 여기서는 이미 개별 Mesh 객체들을 'meshes' 배열에 담았다고 가정합니다.)
          mesh.geometry.computeBoundingBox();
          // mesh.matrixWorld는 Object3D의 전역 위치, 회전, 스케일을 반영합니다.
          // 이것은 mesh가 Group 안에 있을 때 특히 중요합니다.
          bbox.union(mesh.geometry.boundingBox.clone().applyMatrix4(mesh.matrixWorld));
        }
      });

      if (bbox.isEmpty()) {
        console.warn("fitCameraToMeshes: 바운딩 박스가 비어 있습니다. 카메라를 맞출 수 없습니다.");
        return;
      }

      const center = new THREE.Vector3();
      bbox.getCenter(center);
      controls.target.copy(center); // OrbitControls/TrackballControls의 시점(lookAt)을 메시의 중심으로 설정

      const size = new THREE.Vector3();
      bbox.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z); // 메시의 가장 큰 차원

      // 카메라의 FOV(시야각)를 고려하여 메시 전체가 보이도록 카메라 Z 위치 계산
      const fov = camera.fov * (Math.PI / 180); // FOV를 라디안으로 변환
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

      // 약간의 여유 공간(버퍼)을 두어 메시가 너무 가득 차 보이지 않도록 함
      cameraZ *= 1.5; // 이 값은 메시 크기에 따라 조절할 수 있습니다 (1.2 ~ 2.0 정도).

      // 카메라 위치를 메시의 중심을 기준으로 설정
      camera.position.copy(center);
      camera.position.z += cameraZ;
      camera.position.y += cameraZ * 0.5; // 약간 위에서 내려다보는 느낌
      camera.position.x += cameraZ * 0.5; // 약간 옆에서 바라보는 느낌

      camera.lookAt(center); // 카메라가 메시의 중심을 바라보도록 설정
      controls.update(); // 컨트롤러 업데이트 (카메라 위치 변경을 컨트롤러에 반영)
      renderer.render(scene, camera); // 씬 렌더링
      console.log("✅ 메시에 카메라 맞춤 완료.");
    }

    function createMeshRowWithControls(mesh, idx) {
      const labelValue = mesh.label || mesh.userData?.label; // ✅ JSON 객체도 처리 가능
      const labelText = label_name_mapping[labelValue] || `Label ${labelValue}`;
      const row = document.createElement('div');

      row.classList.add('mesh-row');
      Object.assign(row.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        background: '#1A1A1A',
        borderRadius: '8px',
        padding: '8px 12px',
        marginBottom: '8px',
        cursor: 'pointer',
      });

      // ✅ 선택된 메쉬일 경우 강조 표시 추가
      if (selectedMesh === mesh) {
        row.classList.add('selected-row');
      }

      row.onclick = () => {
        selectedMesh = mesh;
        undoStack = [];

        // 항상 기존 강조 제거
        document.querySelectorAll('.selected-row').forEach(el => el.classList.remove('selected-row'));

        // 편집 모드일 때만 강조
        if (editMode) {
          row.classList.add('selected-row');
        }
      };

      const left = createLeftLabelSection(mesh, labelText);
      const controlPanel = createVisibilityAndOpacityControl(mesh);

      row.appendChild(left);
      row.appendChild(controlPanel);

      return row;
    }

    function createLeftLabelSection(mesh, labelText) {
      const color = mesh.material.color || new THREE.Color(0.5, 0.5, 0.5);

      const container = document.createElement('div');
      Object.assign(container.style, {
        display: 'flex',
        alignItems: 'center',
        flex: '1',
      });

      const colorBox = document.createElement('div');
      Object.assign(colorBox.style, {
        width: '12px',
        height: '12px',
        borderRadius: '50%',
        background: `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 1)`,
        marginRight: '8px',
      });

      const label = document.createElement('span');
      label.innerText = labelText;
      Object.assign(label.style, {
        color: '#fff',
        fontSize: '14px',
        flex: '1',
      });

      container.appendChild(colorBox);
      container.appendChild(label);

      return container;
    }

    function createVisibilityAndOpacityControl(mesh) {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.justifyContent = 'space-between';
      container.style.gap = '12px';
      container.style.flex = '1';

      // 왼쪽: 슬라이더 + 숫자
      const sliderGroup = document.createElement('div');
      sliderGroup.style.display = 'flex';
      sliderGroup.style.alignItems = 'center';
      sliderGroup.style.gap = '8px';

      const initialOpacity = mesh.material.opacity ?? 1;
      mesh.material.opacity = initialOpacity;

      const slider = document.createElement('input');
      Object.assign(slider, {
        type: 'range',
        min: 0,
        max: 1,
        step: 0.01,
        value: initialOpacity,
        title: '투명도 조절',
      });
      slider.style.width = '60px';

      const valueText = document.createElement('span');
      valueText.innerText = initialOpacity.toFixed(2);
      valueText.style.fontSize = '12px';
      valueText.style.color = 'white';
      valueText.style.width = '32px';
      valueText.style.textAlign = 'right';

      slider.oninput = (e) => {
        const val = parseFloat(e.target.value);
        mesh.material.opacity = val;
        valueText.innerText = val.toFixed(2);

        if (val < 1.0) {
          Object.assign(mesh.material, {
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.NormalBlending
          });
        } else {
          Object.assign(mesh.material, {
            transparent: false,
            depthWrite: true,
            side: THREE.DoubleSide,
            blending: THREE.NoBlending
          });
        }

        mesh.material.needsUpdate = true;
      };

      sliderGroup.appendChild(slider);
      sliderGroup.appendChild(valueText);

      // 오른쪽: eye 아이콘
      const eye = document.createElement('span');
      eye.style.cursor = 'pointer';
      eye.style.fontSize = '12px';
      eye.style.color = 'white';

      const updateIcon = () => {
        eye.innerHTML = mesh.visible
          ? '<i class="fa-regular fa-eye"></i>'
          : '<i class="fa-regular fa-eye-slash"></i>';
      };

      eye.onclick = (e) => {
        e.stopPropagation();
        mesh.visible = !mesh.visible;
        updateIcon();
        light.position.copy(camera.position);
        renderer.render(scene, camera);
      };

      updateIcon();

      container.appendChild(sliderGroup); // 왼쪽
      container.appendChild(eye);         // 오른쪽

      return container;
    }



  </script>


  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
      background: black;
    }

    header {
      width: 100vw;
      height: 56px;
      /* 필요에 따라 40~80px */
      min-height: 40px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #meshSidebar {
      pointer-events: auto;
      z-index: 10;
      flex: 0 1 270px;
      min-width: 150px;
      border-right: 1px solid #ddd;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
      min-width: 270px;
    }

    #topHalf,
    #bottomHalf {
      width: 100%;
      height: 50%;
    }

    #threeCanvas {
      pointer-events: auto;
      /* 또는 all */
      z-index: 1;
      /* sidebar보다 낮아야 클릭 통과 */
      width: 100%;
      height: 100%;
      display: block;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 10px;
      box-shadow: 0 0 4px rgba(0, 123, 255, 0.3);
    }

    #mainLayout {
      display: flex;
      flex-direction: row;
      /* 명시적으로 좌-중-우 배치 */
      width: 100vw;
      height: calc(100vh - 56px);
      overflow: hidden;
    }

    #viewerArea {
      flex: 1 1 auto;
      /* 남는 공간 다 사용 */
      min-width: 0;
      /* overflow 방지 */
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #volumeTableArea {
      width: 300px;
      background: #000000;
      padding: 16px;
      border-left: 1px solid #ccc;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
      z-index: 1;
    }

    header button,
    header input[type="file"] {
      font-size: 14px;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      margin-right: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    header button:hover,
    header input[type="file"]:hover {
      background-color: #0056b3;
    }

    header button:active,
    header input[type="file"]:active {
      background-color: #004999;
    }

    header #status {
      font-size: 14px;
      color: white;
      margin-left: 12px;
    }

    #volumeTableContent table {
      width: 100%;
      border-collapse: collapse;
      font-size: 15px;
      border: 1px solid #ccc;
    }

    #volumeTableContent thead {
      background-color: #004c7f;
      /* 좀 더 깊은 블루 */
      color: white;
    }

    #volumeTableContent thead th {
      padding: 10px;
      border-bottom: 1px solid #ccc;
      text-align: left;
    }

    #volumeTableContent tbody tr:nth-child(even) {
      background-color: #f2f6f9;
    }

    #volumeTableContent tbody tr:nth-child(odd) {
      background-color: #e8eff5;
    }

    #volumeTableContent tbody td {
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    #volumeTableContent tbody tr:last-child {
      background-color: #e0f0ff;
      /* Total 행 배경 */
      font-weight: bold;
    }

    #volumeTableContent tbody tr:last-child td {
      color: #003366;
    }
  </style>
</body>

</html>